---
title: "Go 面经"
date: 2023-07-15T15:43:21+08:00
draft: False
series_order: 11
---

Go 面经 相关记录

## 基础语法

1. `=` 和 `:=` 的区别？
   * =是赋值变量，:=是定义变量
2. 指针的作用
   * 一个指针可以指向任意变量的地址，它所指向的地址在32位或64位机器上分别**固定**占4或8个字节。指针的作用有
     * 获取变量的值
     * 改变变量的值
     * 用指针替代值传入函数，比如类的接收器就是这样的
3. Go 允许多个返回值吗？
   * 可以。通常函数除了一般返回值还会返回一个error
4. Go 有异常类型吗？
   * 有。Go用error类型代替try...catch语句，这样可以节省资源。同时增加代码可读性
   * 也可以用errors.New()来定义自己的异常。errors.Error()会返回异常的字符串表示。只要实现error接口就可以定义自己的异常，
5. 什么是协程（Goroutine）
   *协程是**用户态轻量级线程**，它是**线程调度的基本单位**。通常在函数前加上go关键字就能实现并发。一个Goroutine会以一个很小的栈启动2KB或4KB，当遇到栈空间不足时，栈会**自动伸缩**， 因此可以轻易实现成千上万个goroutine同时启动
6. 如何高效地拼接字符串
   * 拼接字符串的方式有：`+` , `fmt.Sprintf` , `strings.Builder`, `bytes.Buffer`, `strings.Join`
     * 使用`+`操作符进行拼接时，会对字符串进行遍历，计算并开辟一个新的空间来存储原来的两个字符串由于采用了接口参数，必须要用反射获取值，因此有性能损耗
     * 用WriteString()进行拼接，内部实现是指针+切片，同时String()返回拼接后的字符串，它是直接把[]byte转换为string，从而避免变量拷贝
     * `bytes.Buffer`是一个一个缓冲`byte`类型的缓冲器，这个缓冲器里存放着都是`byte`,`bytes.buffer`底层也是一个`[]byte`切片
     * `strings.join`也是基于`strings.builder`来实现的,并且可以自定义分隔符，在join方法内调用了b.Grow(n)方法，这个是进行初步的容量分配，而前面计算的n的长度就是我们要拼接的slice的长度，因为我们传入切片长度固定，所以提前进行容量分配可以减少内存分配，很高效
   * **性能比较**：strings.Join ≈ strings.Builder > bytes.Buffer > "+" > fmt.Sprintf
7. 什么是 rune 类型
8. 如何判断 map 中是否包含某个 key ？
9.  Go 支持默认参数或可选参数吗？
10. defer 的执行顺序
11. 如何交换 2 个变量的值？
12. Go 语言 tag 的用处？
13. 如何判断 2 个字符串切片（slice) 是相等的？
14. 字符串打印时，`%v` 和 `%+v` 的区别
15. Go 语言中如何表示枚举值(enums)？
16. 空 struct{} 的用途


## 实现原理

1. init() 函数是什么时候执行的
2. Go 语言的局部变量分配在栈上还是堆上？
3. 2 个 interface 可以比较吗 ？
4. 2 个 nil 可能不相等吗？
5. 简述 Go 语言GC(垃圾回收)的工作原理
6. 函数返回局部变量的指针是否安全？
7. 非接口非接口的任意类型 T() 都能够调用 `*T` 的方法吗？反过来呢？

## 并发编程

1. 无缓冲的 channel 和有缓冲的 channel 的区别？
2. 什么是协程泄露(Goroutine Leak)？
3. Go 可以限制运行时操作系统线程的数量吗？

## 代码输出

1. 变量与常量
2. 作用域
3. defer 延迟调用

<!doctype html><html lang=en dir=ltr class=scroll-smooth data-default-appearance=dark data-auto-appearance=true><head><meta charset=utf-8><meta http-equiv=content-language content="en"><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><title>计网面试问题 &#183; NewtSun</title><meta name=title content="计网面试问题 &#183; NewtSun"><meta name=keywords content="MySQL,review,"><link rel=canonical href=https://newtsun.github.io/basic/network/question/><link type=text/css rel=stylesheet href=/css/main.bundle.min.24be37d0eaaebe41c52830ebd6674e9b0772d04c4acf37449ca01896e7adb1599d52a071142e7525f3054f3da0c0aae69065d64bfe59b713d4e8d235fe3c1d54.css integrity="sha512-JL430OquvkHFKDDr1mdOmwdy0ExKzzdEnKAYluetsVmdUqBxFC51JfMFTz2gwKrmkGXWS/5ZtxPU6NI1/jwdVA=="><script type=text/javascript src=/js/appearance.min.516a16745bea5a9bd011138d254cc0fd3973cd55ce6e15f3dec763e7c7c2c7448f8fe7b54cca811cb821b0c7e12cd161caace1dd794ac3d34d40937cbcc9ee12.js integrity="sha512-UWoWdFvqWpvQERONJUzA/TlzzVXObhXz3sdj58fCx0SPj+e1TMqBHLghsMfhLNFhyqzh3XlKw9NNQJN8vMnuEg=="></script>
<script defer type=text/javascript id=script-bundle src=/js/main.bundle.min.3ddcf04f5b0d4c32f72e726d3c12eebccd8c3c9f9daa9a13414808895de0ae1e1cdddda6849680d5bd96dbb60d0b1e0b24c29f5c83e5631e55e7e6bc02015490.js integrity="sha512-PdzwT1sNTDL3LnJtPBLuvM2MPJ+dqpoTQUgIiV3grh4c3d2mhJaA1b2W27YNCx4LJMKfXIPlYx5V5+a8AgFUkA==" data-copy data-copied></script>
<script src=/js/zoom.min.js></script>
<link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta property="og:title" content="计网面试问题"><meta property="og:description" content="总结一些常见的计网面试问题"><meta property="og:type" content="article"><meta property="og:url" content="https://newtsun.github.io/basic/network/question/"><meta property="og:image" content="https://newtsun.github.io/basic/network/question/feature.jpg"><meta property="article:section" content="basic"><meta property="article:published_time" content="2023-09-22T14:38:19+08:00"><meta property="article:modified_time" content="2023-09-22T14:38:19+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://newtsun.github.io/basic/network/question/feature.jpg"><meta name=twitter:title content="计网面试问题"><meta name=twitter:description content="总结一些常见的计网面试问题"><script type=application/ld+json>[{"@context":"https://schema.org","@type":"Article","articleSection":"Basics","name":"计网面试问题","headline":"计网面试问题","abstract":"总结一些常见的计网面试问题","inLanguage":"en","url":"https:\/\/newtsun.github.io\/basic\/network\/question\/","author":{"@type":"Person","name":""},"copyrightYear":"2023","dateCreated":"2023-09-22T14:38:19\u002b08:00","datePublished":"2023-09-22T14:38:19\u002b08:00","dateModified":"2023-09-22T14:38:19\u002b08:00","keywords":["MySQL","review"],"mainEntityOfPage":"true","wordCount":"1463"}]</script><script src=/lib/jquery/jquery.slim.min.js integrity></script><meta name=theme-color></head><body class="flex flex-col h-screen px-6 m-auto text-lg leading-7 max-w-7xl bg-neutral text-neutral-900 dark:bg-neutral-800 dark:text-neutral sm:px-14 md:px-24 lg:px-32"><div id=the-top class="absolute flex self-center"><a class="px-3 py-1 text-sm -translate-y-8 rounded-b-lg bg-primary-200 focus:translate-y-0 dark:bg-neutral-600" href=#main-content><span class="font-bold text-primary-600 ltr:pr-2 rtl:pl-2 dark:text-primary-400">&darr;</span>Skip to main content</a></div><div class=min-h-[148px]></div><div class="fixed inset-x-0 pl-[24px] pr-[24px]" style=z-index:100><div id=menu-blur class="absolute opacity-0 inset-x-0 top-0 h-full single_hero_background nozoom backdrop-blur-2xl shadow-2xl"></div><div class="relative max-w-[64rem] ml-auto mr-auto"><div style=padding-left:0;padding-right:0;padding-top:2px;padding-bottom:3px class="main-menu flex items-center justify-between px-4 py-6 sm:px-6 md:justify-start space-x-3"><div class="flex flex-1 items-center justify-between"><nav class="flex space-x-3"><a href=/ class="text-base font-medium text-gray-500 hover:text-gray-900">NewtSun</a></nav><nav class="hidden md:flex items-center space-x-5 md:ml-12 h-12"><a href=/golang/ class="flex items-center"><p class="text-base font-medium text-gray-500 hover:text-gray-900" title=Golang>Golang</p></a><a href=/python/ class="flex items-center"><p class="text-base font-medium text-gray-500 hover:text-gray-900" title=Pythons>Python</p></a><a href=/linux/ class="flex items-center"><p class="text-base font-medium text-gray-500 hover:text-gray-900" title=Linuxes>Linux</p></a><a href=/basic/ class="flex items-center"><p class="text-base font-medium text-gray-500 hover:text-gray-900" title=Basics>Basic</p></a><a href=/cloud/ class="flex items-center"><p class="text-base font-medium text-gray-500 hover:text-gray-900" title=Clouds>Cloud</p></a><a href=/diary/ class="flex items-center"><p class="text-base font-medium text-gray-500 hover:text-gray-900" title=Diaries>Diary</p></a><button id=search-button aria-label=Search class="text-base hover:text-primary-600 dark:hover:text-primary-400 h-12" title>
<span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></button><div class="ltr:mr-14 rtl:ml-14 cursor-pointer text-sm text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400"><button id=appearance-switcher aria-label="Dark mode switcher" type=button><div class="flex items-center justify-center h-12 dark:hidden"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M32 256C32 132.2 132.3 32 255.8 32c11.36.0 29.7 1.668 40.9 3.746 9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3 9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480 132.1 480 32 379.6 32 256z"/></svg></span></div><div class="items-center justify-center hidden h-12 dark:flex"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M256 159.1c-53.02.0-95.1 42.98-95.1 95.1s41.2 96.9 95.1 96.9 95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347l-63.2-91.9 63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89 164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6 12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256 2.74 347.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7 19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109 109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69.0-127.1-57.31-127.1-127.1.0-70.69 57.31-127.1 127.1-127.1S383.1 186.2 383.1 256c0 70.7-56.4 127.1-127.1 127.1z"/></svg></span></div></button></div></nav><div class="flex md:hidden items-center space-x-5 md:ml-12"><span></span>
<button id=search-button-mobile aria-label=Search class="text-base hover:text-primary-600 dark:hover:text-primary-400" title>
<span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></button>
<button id=appearance-switcher-mobile aria-label="Dark mode switcher" type=button style=margin-right:5px><div class="flex items-center justify-center h-12 dark:hidden"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M32 256C32 132.2 132.3 32 255.8 32c11.36.0 29.7 1.668 40.9 3.746 9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3 9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480 132.1 480 32 379.6 32 256z"/></svg></span></div><div class="items-center justify-center hidden h-12 dark:flex"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M256 159.1c-53.02.0-95.1 42.98-95.1 95.1s41.2 96.9 95.1 96.9 95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347l-63.2-91.9 63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89 164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6 12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256 2.74 347.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7 19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109 109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69.0-127.1-57.31-127.1-127.1.0-70.69 57.31-127.1 127.1-127.1S383.1 186.2 383.1 256c0 70.7-56.4 127.1-127.1 127.1z"/></svg></span></div></button></div></div><div class="-my-2 -mr-2 md:hidden"><label id=menu-button for=menu-controller class=block><input type=checkbox id=menu-controller class=hidden><div class="cursor-pointer hover:text-primary-600 dark:hover:text-primary-400"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentcolor" d="M0 96C0 78.33 14.33 64 32 64H416c17.7.0 32 14.33 32 32 0 17.7-14.3 32-32 32H32C14.33 128 0 113.7.0 96zM0 256c0-17.7 14.33-32 32-32H416c17.7.0 32 14.3 32 32s-14.3 32-32 32H32c-17.67.0-32-14.3-32-32zM416 448H32c-17.67.0-32-14.3-32-32s14.33-32 32-32H416c17.7.0 32 14.3 32 32s-14.3 32-32 32z"/></svg></span></div><div id=menu-wrapper style=padding-top:5px class="fixed inset-0 z-30 invisible w-screen h-screen m-0 overflow-auto transition-opacity opacity-0 cursor-default bg-neutral-100/50 backdrop-blur-sm dark:bg-neutral-900/50"><ul class="flex space-y-2 mt-3 flex-col items-end w-full px-6 py-6 mx-auto overflow-visible list-none ltr:text-right rtl:text-left max-w-7xl"><li><span class="cursor-pointer inline-block align-text-bottom hover:text-primary-600 dark:hover:text-primary-400"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path fill="currentcolor" d="M310.6 361.4c12.5 12.5 12.5 32.75.0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3 54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75.0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75.0-45.25s32.75-12.5 45.25.0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25.0s12.5 32.75.0 45.25l-105.4 105.4L310.6 361.4z"/></svg></span></span></li><li class=mt-1><a href=/golang/ class="flex items-center"><p class="text-bg font-bg text-gray-500 hover:text-gray-900" title=Golang>Golang</p></a></li><li class=mt-1><a href=/python/ class="flex items-center"><p class="text-bg font-bg text-gray-500 hover:text-gray-900" title=Pythons>Python</p></a></li><li class=mt-1><a href=/linux/ class="flex items-center"><p class="text-bg font-bg text-gray-500 hover:text-gray-900" title=Linuxes>Linux</p></a></li><li class=mt-1><a href=/basic/ class="flex items-center"><p class="text-bg font-bg text-gray-500 hover:text-gray-900" title=Basics>Basic</p></a></li><li class=mt-1><a href=/cloud/ class="flex items-center"><p class="text-bg font-bg text-gray-500 hover:text-gray-900" title=Clouds>Cloud</p></a></li><li class=mt-1><a href=/diary/ class="flex items-center"><p class="text-bg font-bg text-gray-500 hover:text-gray-900" title=Diaries>Diary</p></a></li></ul></div></label></div></div><script>(function(){var e=$(".main-menu"),t=window.location.pathname;e.find('a[href="'+t+'"]').each(function(e,t){$(t).children("p").addClass("active")})})()</script></div></div><script>window.addEventListener("scroll",function(){var t=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0,n=document.getElementById("menu-blur");n.style.opacity=t/300})</script><div class="relative flex flex-col grow"><main id=main-content class=grow><article><div id=hero class="h-[150px] md:h-[200px]"></div><div class="fixed inset-x-0 top-0 h-[800px] single_hero_background nozoom" style=background-image:url(/basic/network/question/feature_hueec000e836700e47a400518ee0f20552_217352_1200x0_resize_q75_box.jpg)><div class="absolute inset-0 bg-gradient-to-t from-neutral dark:from-neutral-800 to-transparent mix-blend-normal"></div><div class="absolute inset-0 opacity-60 bg-gradient-to-t from-neutral dark:from-neutral-800 to-neutral-100 dark:to-neutral-800 mix-blend-normal"></div></div><div id=background-blur class="fixed opacity-0 inset-x-0 top-0 h-full single_hero_background nozoom backdrop-blur-2xl"></div><script>window.addEventListener("scroll",function(){var t=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0,n=document.getElementById("background-blur");n.style.opacity=t/300})</script><header id=single_header class="mt-5 max-w-prose"><ol class="text-sm text-neutral-500 dark:text-neutral-400 print:hidden"><li class="inline hidden"><a class="hover:underline decoration-neutral-300 dark:underline-neutral-600" href=/>Welcome to NewtSun</a><span class="px-1 text-primary-500">/</span></li><li class=inline><a class="hover:underline decoration-neutral-300 dark:underline-neutral-600" href=/basic/>Basics</a><span class="px-1 text-primary-500">/</span></li><li class="inline hidden"><a class="hover:underline decoration-neutral-300 dark:underline-neutral-600" href=/basic/network/question/>计网面试问题</a><span class="px-1 text-primary-500">/</span></li></ol><h1 class="mt-0 text-4xl font-extrabold text-neutral-900 dark:text-neutral">计网面试问题</h1><div class="mt-1 mb-6 text-base text-neutral-500 dark:text-neutral-400 print:hidden"><div class="flex flex-row flex-wrap items-center"><time datetime="2023-09-22 14:38:19 +0800 +0800">22 September 2023</time><span class="px-2 text-primary-500">&#183;</span><span title="Reading time">7 mins</span></div><div class="flex flex-row flex-wrap items-center"><span style=margin-top:.5rem class=mr-2 onclick='window.open("/tags/mysql/","_self")'><span class=flex><span class="rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400">MySQL</span></span></span>
<span style=margin-top:.5rem class=mr-2 onclick='window.open("/tags/review/","_self")'><span class=flex><span class="rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400">review</span></span></span></div></div><div class=flex><div class=place-self-center><div class="text-2xl sm:text-lg"></div></div></div><div class=mb-5></div></header><section class="flex flex-col max-w-full mt-0 prose dark:prose-invert lg:flex-row"><div class="order-first sm:max-w-prose lg:ml-auto px-0 lg:order-last lg:max-w-xs ltr:lg:pl-8 rtl:lg:pr-8"><div class="toc ltr:pl-5 rtl:pr-5 print:hidden lg:sticky lg:top-[140px]"><details open class="mt-0 overflow-hidden rounded-lg ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 hidden lg:block"><summary class="block py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">Table of Contents</summary><div class="min-w-[220px] py-2 border-dotted border-neutral-300 ltr:-ml-5 ltr:border-l ltr:pl-5 rtl:-mr-5 rtl:border-r rtl:pr-5 dark:border-neutral-600"><nav id=TableOfContents><ul><li><a href=#1http>1.HTTP</a><ul><li><a href=#11-http-常见的状态码>1.1 HTTP 常见的状态码</a></li><li><a href=#12-http-与-https-的区别>1.2 HTTP 与 HTTPS 的区别</a></li><li><a href=#13-https-解决了-http-的哪些问题>1.3 HTTPS 解决了 HTTP 的哪些问题</a></li><li><a href=#14-https-如何建立连接>1.4 HTTPS 如何建立连接</a></li><li><a href=#15-客户端校验数字证书的流程>1.5 客户端校验数字证书的流程</a></li><li><a href=#16-https-的应用数据是如何保证完整性>1.6 HTTPS 的应用数据是如何保证完整性</a></li><li><a href=#17-http11-相比-http10-提高了什么性能>1.7 HTTP/1.1 相比 HTTP/1.0 提高了什么性能</a></li><li><a href=#18-http2-做了什么优化>1.8 HTTP/2 做了什么优化</a></li><li><a href=#19-http2-有什么缺陷>1.9 HTTP/2 有什么缺陷</a></li><li><a href=#110-http3-做了什么优化>1.10 HTTP/3 做了什么优化</a></li><li><a href=#111-https-和-http-相比只是传输的内容多了对称加密吗>1.11 https 和 http 相比，只是传输的内容多了对称加密吗</a></li><li><a href=#112-为啥-ssl-的握手是-4-次>1.12 为啥 SSL 的握手是 4 次</a></li><li><a href=#113-优化-http11-协议的思路>1.13 优化 HTTP/1.1 协议的思路</a><ul><li><a href=#1131-如何避免发送-http-请求>1.13.1 如何避免发送 HTTP 请求</a></li><li><a href=#1132-如何减少-http-请求次数>1.13.2 如何减少 HTTP 请求次数</a></li><li><a href=#1133-如何减少-http-响应数据大小>1.13.3 如何减少 HTTP 响应数据大小</a></li></ul></li><li><a href=#114-tls-握手过程>1.14 TLS 握手过程</a></li><li><a href=#115-rsa-握手过程>1.15 RSA 握手过程</a><ul><li><a href=#1151-tls-第一次握手>1.15.1 TLS 第一次握手</a></li><li><a href=#1152-tls-第二次握手>1.15.2 TLS 第二次握手</a></li><li><a href=#1153-tls-第三次握手>1.15.3 TLS 第三次握手</a></li><li><a href=#1154-tls-第四次握手>1.15.4 TLS 第四次握手</a></li></ul></li><li><a href=#116-rsa-算法的缺陷>1.16 RSA 算法的缺陷</a></li><li><a href=#117-https-如何优化>1.17 HTTPS 如何优化</a><ul><li><a href=#1171-硬件优化>1.17.1 硬件优化</a></li><li><a href=#1172-软件优化>1.17.2 软件优化</a></li><li><a href=#1173-协议优化>1.17.3 协议优化</a></li><li><a href=#1174-证书优化>1.17.4 证书优化</a></li><li><a href=#1175-会话复用>1.17.5 会话复用</a></li></ul></li></ul></li><li><a href=#2tcp>2.TCP</a></li></ul></nav></div></details><details class="mt-0 overflow-hidden rounded-lg ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 lg:hidden"><summary class="py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">Table of Contents</summary><div class="py-2 border-dotted border-neutral-300 ltr:-ml-5 ltr:border-l ltr:pl-5 rtl:-mr-5 rtl:border-r rtl:pr-5 dark:border-neutral-600"><nav id=TableOfContents><ul><li><a href=#1http>1.HTTP</a><ul><li><a href=#11-http-常见的状态码>1.1 HTTP 常见的状态码</a></li><li><a href=#12-http-与-https-的区别>1.2 HTTP 与 HTTPS 的区别</a></li><li><a href=#13-https-解决了-http-的哪些问题>1.3 HTTPS 解决了 HTTP 的哪些问题</a></li><li><a href=#14-https-如何建立连接>1.4 HTTPS 如何建立连接</a></li><li><a href=#15-客户端校验数字证书的流程>1.5 客户端校验数字证书的流程</a></li><li><a href=#16-https-的应用数据是如何保证完整性>1.6 HTTPS 的应用数据是如何保证完整性</a></li><li><a href=#17-http11-相比-http10-提高了什么性能>1.7 HTTP/1.1 相比 HTTP/1.0 提高了什么性能</a></li><li><a href=#18-http2-做了什么优化>1.8 HTTP/2 做了什么优化</a></li><li><a href=#19-http2-有什么缺陷>1.9 HTTP/2 有什么缺陷</a></li><li><a href=#110-http3-做了什么优化>1.10 HTTP/3 做了什么优化</a></li><li><a href=#111-https-和-http-相比只是传输的内容多了对称加密吗>1.11 https 和 http 相比，只是传输的内容多了对称加密吗</a></li><li><a href=#112-为啥-ssl-的握手是-4-次>1.12 为啥 SSL 的握手是 4 次</a></li><li><a href=#113-优化-http11-协议的思路>1.13 优化 HTTP/1.1 协议的思路</a><ul><li><a href=#1131-如何避免发送-http-请求>1.13.1 如何避免发送 HTTP 请求</a></li><li><a href=#1132-如何减少-http-请求次数>1.13.2 如何减少 HTTP 请求次数</a></li><li><a href=#1133-如何减少-http-响应数据大小>1.13.3 如何减少 HTTP 响应数据大小</a></li></ul></li><li><a href=#114-tls-握手过程>1.14 TLS 握手过程</a></li><li><a href=#115-rsa-握手过程>1.15 RSA 握手过程</a><ul><li><a href=#1151-tls-第一次握手>1.15.1 TLS 第一次握手</a></li><li><a href=#1152-tls-第二次握手>1.15.2 TLS 第二次握手</a></li><li><a href=#1153-tls-第三次握手>1.15.3 TLS 第三次握手</a></li><li><a href=#1154-tls-第四次握手>1.15.4 TLS 第四次握手</a></li></ul></li><li><a href=#116-rsa-算法的缺陷>1.16 RSA 算法的缺陷</a></li><li><a href=#117-https-如何优化>1.17 HTTPS 如何优化</a><ul><li><a href=#1171-硬件优化>1.17.1 硬件优化</a></li><li><a href=#1172-软件优化>1.17.2 软件优化</a></li><li><a href=#1173-协议优化>1.17.3 协议优化</a></li><li><a href=#1174-证书优化>1.17.4 证书优化</a></li><li><a href=#1175-会话复用>1.17.5 会话复用</a></li></ul></li></ul></li><li><a href=#2tcp>2.TCP</a></li></ul></nav></div></details><script>(function(){var t,e=$("#TableOfContents");if(e.length>0){t=$(window);function n(){var s,o=t.scrollTop(),i=$(".anchor"),n="";if(i.each(function(e,t){t=$(t),t.offset().top-$(window).height()/3<=o&&(n=t.attr("id"))}),s=e.find("a.active"),s.length==1&&s.eq(0).attr("href")=="#"+n)return!0;s.each(function(e,t){$(t).removeClass("active")}),e.find('a[href="#'+n+'"]').addClass("active"),e.find('a[href="#'+n+'"]').parentsUntil("#TableOfContents").each(function(e,t){$(t).children("a").parents("ul").show()})}t.on("scroll",n),$(document).ready(function(){n()})}})()</script></div></div><div class="min-w-0 min-h-0 max-w-fit"><div class="max-w-prose mb-20"><p>总结一些常见的计网面试问题</p><div id=1http class=anchor></div><h2 class="relative group">1.HTTP
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#1http aria-label=Anchor>#</a></span></h2><div id=11-http-常见的状态码 class=anchor></div><h3 class="relative group">1.1 HTTP 常见的状态码
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#11-http-%e5%b8%b8%e8%a7%81%e7%9a%84%e7%8a%b6%e6%80%81%e7%a0%81 aria-label=Anchor>#</a></span></h3><p><figure><img class="my-0 rounded-md" srcset="/basic/network/question/img/image-20230922194302658_hu708f162ee7cf1d9e159d272898acaf36_449560_330x0_resize_box_3.png 330w,
/basic/network/question/img/image-20230922194302658_hu708f162ee7cf1d9e159d272898acaf36_449560_660x0_resize_box_3.png 660w,
/basic/network/question/img/image-20230922194302658_hu708f162ee7cf1d9e159d272898acaf36_449560_1024x0_resize_box_3.png 1024w,
/basic/network/question/img/image-20230922194302658_hu708f162ee7cf1d9e159d272898acaf36_449560_1320x0_resize_box_3.png 2x" src=/basic/network/question/img/image-20230922194302658_hu708f162ee7cf1d9e159d272898acaf36_449560_660x0_resize_box_3.png alt></figure></p><p><code>1xx</code> 类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少。</p><p><code>2xx</code> 类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态。</p><ul><li>「<strong>200 OK</strong>」是最常见的成功状态码，表示一切正常。如果是非 <code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据。</li><li>「<strong>204 No Content</strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</li><li>「<strong>206 Partial Content</strong>」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li></ul><p><code>3xx</code> 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</p><ul><li>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</li><li>「<strong>302 Found</strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</li></ul><p>301 和 302 都会在响应头里使用字段 <code>Location</code>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p><ul><li>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。</li></ul><p><code>4xx</code> 类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</p><ul><li>「<strong>400 Bad Request</strong>」表示客户端请求的报文有错误，但只是个笼统的错误。</li><li>「<strong>403 Forbidden</strong>」表示服务器禁止访问资源，并不是客户端的请求出错。</li><li>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li></ul><p><code>5xx</code> 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</p><ul><li>「<strong>500 Internal Server Error</strong>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</li><li>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li><li>「<strong>502 Bad Gateway</strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li><li>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。</li></ul><div id=12-http-与-https-的区别 class=anchor></div><h3 class="relative group">1.2 HTTP 与 HTTPS 的区别
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#12-http-%e4%b8%8e-https-%e7%9a%84%e5%8c%ba%e5%88%ab aria-label=Anchor>#</a></span></h3><ul><li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。</li><li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。</li><li>两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</li><li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li></ul><div id=13-https-解决了-http-的哪些问题 class=anchor></div><h3 class="relative group">1.3 HTTPS 解决了 HTTP 的哪些问题
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#13-https-%e8%a7%a3%e5%86%b3%e4%ba%86-http-%e7%9a%84%e5%93%aa%e4%ba%9b%e9%97%ae%e9%a2%98 aria-label=Anchor>#</a></span></h3><p>HTTP 由于是明文传输，所以安全上存在以下三个风险：</p><ul><li><strong>窃听风险</strong>，比如通信链路上可以获取通信内容，用户号容易没。</li><li><strong>篡改风险</strong>，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。</li><li><strong>冒充风险</strong>，比如冒充淘宝网站，用户钱容易没。</li></ul><p><figure><img class="my-0 rounded-md" srcset="/basic/network/question/img/image-20230922194823717_hudbee7d559637eef2d0e3bef7c0d19570_89770_330x0_resize_box_3.png 330w,
/basic/network/question/img/image-20230922194823717_hudbee7d559637eef2d0e3bef7c0d19570_89770_660x0_resize_box_3.png 660w,
/basic/network/question/img/image-20230922194823717_hudbee7d559637eef2d0e3bef7c0d19570_89770_1024x0_resize_box_3.png 1024w,
/basic/network/question/img/image-20230922194823717_hudbee7d559637eef2d0e3bef7c0d19570_89770_1320x0_resize_box_3.png 2x" src=/basic/network/question/img/image-20230922194823717_hudbee7d559637eef2d0e3bef7c0d19570_89770_660x0_resize_box_3.png alt></figure></p><p>HTTP<strong>S</strong> 在 HTTP 与 TCP 层之间加入了 <code>SSL/TLS</code> 协议，可以很好的解决了上述的风险：</p><ul><li><strong>信息加密</strong>：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。</li><li><strong>校验机制</strong>：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。</li><li><strong>身份证书</strong>：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。</li></ul><p>可见，只要自身不做「恶」，SSL/TLS 协议是能保证通信是安全的。</p><blockquote><p>HTTPS 是如何解决上面的三个风险的？</p></blockquote><ul><li><strong>混合加密</strong>的方式实现信息的<strong>机密性</strong>，解决了窃听的风险。</li><li><strong>摘要算法</strong>的方式来实现<strong>完整性</strong>，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</li><li>将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险。</li></ul><div id=14-https-如何建立连接 class=anchor></div><h3 class="relative group">1.4 HTTPS 如何建立连接
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#14-https-%e5%a6%82%e4%bd%95%e5%bb%ba%e7%ab%8b%e8%bf%9e%e6%8e%a5 aria-label=Anchor>#</a></span></h3><p>SSL/TLS 协议基本流程：</p><ul><li>客户端向服务器索要并验证服务器的公钥。</li><li>双方协商生产「会话秘钥」。</li><li>双方采用「会话秘钥」进行加密通信。</li></ul><p>前两步也就是 SSL/TLS 的建立过程，也就是 TLS 握手阶段。</p><p>TLS 的「握手阶段」涉及<strong>四次</strong>通信，使用不同的密钥交换算法，TLS 握手流程也会不一样的，现在常用的密钥交换算法有两种：RSA 算法 (opens new window)和 ECDHE 算法 (opens new window)。</p><p>基于 RSA 算法的 TLS 握手过程比较容易理解，所以这里先用这个给大家展示 TLS 握手过程，如下图：</p><p><figure><img class="my-0 rounded-md" srcset="/basic/network/question/img/image-20230922194943917_hu2e7cc08624906930d4655ffdc9e18f70_1231867_330x0_resize_box_3.png 330w,
/basic/network/question/img/image-20230922194943917_hu2e7cc08624906930d4655ffdc9e18f70_1231867_660x0_resize_box_3.png 660w,
/basic/network/question/img/image-20230922194943917_hu2e7cc08624906930d4655ffdc9e18f70_1231867_1024x0_resize_box_3.png 1024w,
/basic/network/question/img/image-20230922194943917_hu2e7cc08624906930d4655ffdc9e18f70_1231867_1320x0_resize_box_3.png 2x" src=/basic/network/question/img/image-20230922194943917_hu2e7cc08624906930d4655ffdc9e18f70_1231867_660x0_resize_box_3.png alt></figure></p><p>TLS 协议建立的详细流程：</p><p><strong>1.ClientHello</strong></p><p>首先，由客户端向服务器发起加密通信请求，也就是 <code>ClientHello</code> 请求。</p><p>在这一步，客户端主要向服务器发送以下信息：</p><p>（1）客户端支持的 TLS 协议版本，如 TLS 1.2 版本。</p><p>（2）客户端生产的随机数（<code>Client Random</code>），后面用于生成「会话秘钥」条件之一。</p><p>（3）客户端支持的密码套件列表，如 RSA 加密算法。</p><p><strong>2.SeverHello</strong></p><p>服务器收到客户端请求后，向客户端发出响应，也就是 <code>SeverHello</code>。服务器回应的内容有如下内容：</p><p>（1）确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。</p><p>（2）服务器生产的随机数（<code>Server Random</code>），也是后面用于生产「会话秘钥」条件之一。</p><p>（3）确认的密码套件列表，如 RSA 加密算法。</p><p>（4）服务器的数字证书。</p><p><strong>3.客户端回应</strong></p><p>客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。</p><p>如果证书没有问题，客户端会<strong>从数字证书中取出服务器的公钥</strong>，然后使用它加密报文，向服务器发送如下信息：</p><p>（1）一个随机数（<code>pre-master key</code>）。该随机数会被服务器公钥加密。</p><p>（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</p><p>（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</p><p>上面第一项的随机数是整个握手阶段的第三个随机数，会发给服务端，所以这个随机数客户端和服务端都是一样的。</p><p><strong>服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」</strong>。</p><p><em>4. 服务器的最后回应</em></p><p>服务器收到客户端的第三个随机数（<code>pre-master key</code>）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。</p><p>然后，向客户端发送最后的信息：</p><p>（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</p><p>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</p><p>至此，整个 TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。</p><div id=15-客户端校验数字证书的流程 class=anchor></div><h3 class="relative group">1.5 客户端校验数字证书的流程
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#15-%e5%ae%a2%e6%88%b7%e7%ab%af%e6%a0%a1%e9%aa%8c%e6%95%b0%e5%ad%97%e8%af%81%e4%b9%a6%e7%9a%84%e6%b5%81%e7%a8%8b aria-label=Anchor>#</a></span></h3><p><figure><img class="my-0 rounded-md" srcset="/basic/network/question/img/image-20230922195301498_hu9435568d0cd9cc8906d383efd48fc5f7_336269_330x0_resize_box_3.png 330w,
/basic/network/question/img/image-20230922195301498_hu9435568d0cd9cc8906d383efd48fc5f7_336269_660x0_resize_box_3.png 660w,
/basic/network/question/img/image-20230922195301498_hu9435568d0cd9cc8906d383efd48fc5f7_336269_1024x0_resize_box_3.png 1024w,
/basic/network/question/img/image-20230922195301498_hu9435568d0cd9cc8906d383efd48fc5f7_336269_1320x0_resize_box_3.png 2x" src=/basic/network/question/img/image-20230922195301498_hu9435568d0cd9cc8906d383efd48fc5f7_336269_660x0_resize_box_3.png alt></figure></p><p>CA 签发证书的过程，如上图左边部分：</p><ul><li>首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；</li><li>然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；</li><li>最后将 Certificate Signature 添加在文件证书上，形成数字证书；</li></ul><p>客户端校验服务端的数字证书的过程，如上图右边部分：</p><ul><li>首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；</li><li>通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；</li><li>最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。</li></ul><div id=16-https-的应用数据是如何保证完整性 class=anchor></div><h3 class="relative group">1.6 HTTPS 的应用数据是如何保证完整性
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#16-https-%e7%9a%84%e5%ba%94%e7%94%a8%e6%95%b0%e6%8d%ae%e6%98%af%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e5%ae%8c%e6%95%b4%e6%80%a7 aria-label=Anchor>#</a></span></h3><p>TLS 在实现上分为<strong>握手协议</strong>和<strong>记录协议</strong>两层：</p><ul><li>TLS 握手协议就是我们前面说的 TLS 四次握手的过程，负责协商加密算法和生成对称密钥，后续用此密钥来保护应用程序数据（即 HTTP 数据）；</li><li>TLS 记录协议负责保护应用程序数据并验证其完整性和来源，所以对 HTTP 数据加密是使用记录协议；</li></ul><p>TLS 记录协议主要负责消息（HTTP 数据）的压缩，加密及数据的认证，过程如下图：</p><p><figure><img class="my-0 rounded-md" srcset="/basic/network/question/img/image-20230922195407955_hud828befb9936bf1eece581c47251505f_402462_330x0_resize_box_3.png 330w,
/basic/network/question/img/image-20230922195407955_hud828befb9936bf1eece581c47251505f_402462_660x0_resize_box_3.png 660w,
/basic/network/question/img/image-20230922195407955_hud828befb9936bf1eece581c47251505f_402462_1024x0_resize_box_3.png 1024w,
/basic/network/question/img/image-20230922195407955_hud828befb9936bf1eece581c47251505f_402462_1320x0_resize_box_3.png 2x" src=/basic/network/question/img/image-20230922195407955_hud828befb9936bf1eece581c47251505f_402462_660x0_resize_box_3.png alt></figure></p><p>具体过程如下：</p><ul><li>首先，消息被分割成多个较短的片段,然后分别对每个片段进行压缩。</li><li>接下来，经过压缩的片段会被<strong>加上消息认证码（MAC 值，这个是通过哈希算法生成的），这是为了保证完整性，并进行数据的认证</strong>。通过附加消息认证码的 MAC 值，可以识别出篡改。与此同时，为了防止重放攻击，在计算消息认证码时，还加上了片段的编码。</li><li>再接下来，经过压缩的片段再加上消息认证码会一起通过对称密码进行加密。</li><li>最后，上述经过加密的数据再加上由数据类型、版本号、压缩后的长度组成的报头就是最终的报文数据。</li></ul><p>记录协议完成后，最终的报文数据将传递到传输控制协议 (TCP) 层进行传输。</p><div id=17-http11-相比-http10-提高了什么性能 class=anchor></div><h3 class="relative group">1.7 HTTP/1.1 相比 HTTP/1.0 提高了什么性能
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#17-http11-%e7%9b%b8%e6%af%94-http10-%e6%8f%90%e9%ab%98%e4%ba%86%e4%bb%80%e4%b9%88%e6%80%a7%e8%83%bd aria-label=Anchor>#</a></span></h3><p>HTTP/1.1 相比 HTTP/1.0 性能上的改进：</p><ul><li>使用长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。</li><li>支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</li></ul><p>但 HTTP/1.1 还是有性能瓶颈：</p><ul><li>请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 <code>Body</code> 的部分；</li><li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多；</li><li>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；</li><li>没有请求优先级控制；</li><li>请求只能从客户端开始，服务器只能被动响应。</li></ul><div id=18-http2-做了什么优化 class=anchor></div><h3 class="relative group">1.8 HTTP/2 做了什么优化
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#18-http2-%e5%81%9a%e4%ba%86%e4%bb%80%e4%b9%88%e4%bc%98%e5%8c%96 aria-label=Anchor>#</a></span></h3><p>HTTP/2 协议是基于 HTTPS 的，所以 HTTP/2 的安全性也是有保障的。</p><p><figure><img class="my-0 rounded-md" srcset="/basic/network/question/img/image-20230922195601345_hu088b627261b569f78d7663df6c728784_152952_330x0_resize_box_3.png 330w,
/basic/network/question/img/image-20230922195601345_hu088b627261b569f78d7663df6c728784_152952_660x0_resize_box_3.png 660w,
/basic/network/question/img/image-20230922195601345_hu088b627261b569f78d7663df6c728784_152952_1024x0_resize_box_3.png 1024w,
/basic/network/question/img/image-20230922195601345_hu088b627261b569f78d7663df6c728784_152952_1320x0_resize_box_3.png 2x" src=/basic/network/question/img/image-20230922195601345_hu088b627261b569f78d7663df6c728784_152952_660x0_resize_box_3.png alt></figure></p><p>那 HTTP/2 相比 HTTP/1.1 性能上的改进：</p><ul><li>头部压缩</li><li>二进制格式</li><li>并发传输</li><li>服务器主动推送资源</li></ul><p><strong>1.头部压缩</strong></p><p>HTTP/2 会<strong>压缩头</strong>（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你<strong>消除重复的部分</strong>。</p><p>这就是所谓的 <code>HPACK</code> 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就<strong>提高速度</strong>了。</p><p><strong>2.二进制格式</strong></p><p>HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了<strong>二进制格式</strong>，头信息和数据体都是二进制，并且统称为帧（frame）：<strong>头信息帧（Headers Frame）和数据帧（Data Frame）</strong>。</p><p><figure><img class="my-0 rounded-md" srcset="/basic/network/question/img/image-20230922195624918_hud19eec977cd1b7857472fd9627e196f7_201134_330x0_resize_box_3.png 330w,
/basic/network/question/img/image-20230922195624918_hud19eec977cd1b7857472fd9627e196f7_201134_660x0_resize_box_3.png 660w,
/basic/network/question/img/image-20230922195624918_hud19eec977cd1b7857472fd9627e196f7_201134_1024x0_resize_box_3.png 1024w,
/basic/network/question/img/image-20230922195624918_hud19eec977cd1b7857472fd9627e196f7_201134_1320x0_resize_box_3.png 2x" src=/basic/network/question/img/image-20230922195624918_hud19eec977cd1b7857472fd9627e196f7_201134_660x0_resize_box_3.png alt></figure></p><p>这样虽然对人不友好，但是对计算机非常友好，因为计算机只懂二进制，那么收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这<strong>增加了数据传输的效率</strong>。</p><p>比如状态码 200 ，在 HTTP/1.1 是用 &lsquo;2&rsquo;&lsquo;0&rsquo;&lsquo;0&rsquo; 三个字符来表示（二进制：00110010 00110000 00110000），共用了 3 个字节，如下图：</p><p><figure><img class="my-0 rounded-md" srcset="/basic/network/question/img/image-20230922195640411_hua90393cd21b8c986de2c280cc906a2b8_1387864_330x0_resize_box_3.png 330w,
/basic/network/question/img/image-20230922195640411_hua90393cd21b8c986de2c280cc906a2b8_1387864_660x0_resize_box_3.png 660w,
/basic/network/question/img/image-20230922195640411_hua90393cd21b8c986de2c280cc906a2b8_1387864_1024x0_resize_box_3.png 1024w,
/basic/network/question/img/image-20230922195640411_hua90393cd21b8c986de2c280cc906a2b8_1387864_1320x0_resize_box_3.png 2x" src=/basic/network/question/img/image-20230922195640411_hua90393cd21b8c986de2c280cc906a2b8_1387864_660x0_resize_box_3.png alt></figure></p><p>在 HTTP/2 对于状态码 200 的二进制编码是 10001000，只用了 1 字节就能表示，相比于 HTTP/1.1 节省了 2 个字节，如下图：</p><p><figure><img class="my-0 rounded-md" srcset="/basic/network/question/img/image-20230922195650439_huddf56251a40d00687e10a557c844f363_2262103_330x0_resize_box_3.png 330w,
/basic/network/question/img/image-20230922195650439_huddf56251a40d00687e10a557c844f363_2262103_660x0_resize_box_3.png 660w,
/basic/network/question/img/image-20230922195650439_huddf56251a40d00687e10a557c844f363_2262103_1024x0_resize_box_3.png 1024w,
/basic/network/question/img/image-20230922195650439_huddf56251a40d00687e10a557c844f363_2262103_1320x0_resize_box_3.png 2x" src=/basic/network/question/img/image-20230922195650439_huddf56251a40d00687e10a557c844f363_2262103_660x0_resize_box_3.png alt></figure></p><p>Header: :status: 200 OK 的编码内容为：1000 1000</p><p><figure><img class="my-0 rounded-md" srcset="/basic/network/question/img/image-20230922195708148_hu0babe503e1789588fde6f593c176b16b_15867_330x0_resize_box_3.png 330w,
/basic/network/question/img/image-20230922195708148_hu0babe503e1789588fde6f593c176b16b_15867_660x0_resize_box_3.png 660w,
/basic/network/question/img/image-20230922195708148_hu0babe503e1789588fde6f593c176b16b_15867_1024x0_resize_box_3.png 1024w,
/basic/network/question/img/image-20230922195708148_hu0babe503e1789588fde6f593c176b16b_15867_1320x0_resize_box_3.png 2x" src=/basic/network/question/img/image-20230922195708148_hu0babe503e1789588fde6f593c176b16b_15867_660x0_resize_box_3.png alt></figure></p><ul><li><p>最前面的 1 标识该 Header 是静态表中已经存在的 KV。</p></li><li><p>在静态表里，“:status: 200 ok” 静态表编码是 8，二进制即是 1000。</p></li></ul><p>因此，整体加起来就是 1000 1000。</p><p><strong>3.并发传输</strong></p><p>我们都知道 HTTP/1.1 的实现是基于请求-响应模型的。同一个连接中，HTTP 完成一个事务（请求与响应），才能处理下一个事务，也就是说在发出请求等待响应的过程中，是没办法做其他事情的，如果响应迟迟不来，那么后续的请求是无法发送的，也造成了<strong>队头阻塞</strong>的问题。</p><p>而 HTTP/2 就很牛逼了，引出了 Stream 概念，多个 Stream 复用在一条 TCP 连接。</p><p><figure><img class="my-0 rounded-md" srcset="/basic/network/question/img/image-20230922195906490_hu762ebcdce071cf3a513525f575a6358d_142602_330x0_resize_box_3.png 330w,
/basic/network/question/img/image-20230922195906490_hu762ebcdce071cf3a513525f575a6358d_142602_660x0_resize_box_3.png 660w,
/basic/network/question/img/image-20230922195906490_hu762ebcdce071cf3a513525f575a6358d_142602_1024x0_resize_box_3.png 1024w,
/basic/network/question/img/image-20230922195906490_hu762ebcdce071cf3a513525f575a6358d_142602_1320x0_resize_box_3.png 2x" src=/basic/network/question/img/image-20230922195906490_hu762ebcdce071cf3a513525f575a6358d_142602_660x0_resize_box_3.png alt></figure></p><p>从上图可以看到，1 个 TCP 连接包含多个 Stream，Stream 里可以包含 1 个或多个 Message，Message 对应 HTTP/1 中的请求或响应，由 HTTP 头部和包体构成。Message 里包含一条或者多个 Frame，Frame 是 HTTP/2 最小单位，以二进制压缩格式存放 HTTP/1 中的内容（头部和包体）。</p><p><strong>针对不同的 HTTP 请求用独一无二的 Stream ID 来区分，接收端可以通过 Stream ID 有序组装成 HTTP 消息，不同 Stream 的帧是可以乱序发送的，因此可以并发不同的 Stream ，也就是 HTTP/2 可以并行交错地发送请求和响应</strong>。</p><p>比如下图，服务端<strong>并行交错地</strong>发送了两个响应： Stream 1 和 Stream 3，这两个 Stream 都是跑在一个 TCP 连接上，客户端收到后，会根据相同的 Stream ID 有序组装成 HTTP 消息。</p><p><figure><img class="my-0 rounded-md" srcset="/basic/network/question/img/image-20230922195915005_hu3bfce40e20bd06bec00b9b9ecba128f6_95879_330x0_resize_box_3.png 330w,
/basic/network/question/img/image-20230922195915005_hu3bfce40e20bd06bec00b9b9ecba128f6_95879_660x0_resize_box_3.png 660w,
/basic/network/question/img/image-20230922195915005_hu3bfce40e20bd06bec00b9b9ecba128f6_95879_1024x0_resize_box_3.png 1024w,
/basic/network/question/img/image-20230922195915005_hu3bfce40e20bd06bec00b9b9ecba128f6_95879_1320x0_resize_box_3.png 2x" src=/basic/network/question/img/image-20230922195915005_hu3bfce40e20bd06bec00b9b9ecba128f6_95879_660x0_resize_box_3.png alt></figure></p><p><strong>4.服务器推送</strong></p><p>HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务端不再是被动地响应，可以<strong>主动</strong>向客户端发送消息。</p><p>客户端和服务器<strong>双方都可以建立 Stream</strong>， Stream ID 也是有区别的，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。</p><p>比如下图，Stream 1 是客户端向服务端请求的资源，属于客户端建立的 Stream，所以该 Stream 的 ID 是奇数（数字 1）；Stream 2 和 4 都是服务端主动向客户端推送的资源，属于服务端建立的 Stream，所以这两个 Stream 的 ID 是偶数（数字 2 和 4）。</p><p><figure><img class="my-0 rounded-md" srcset="/basic/network/question/img/image-20230922195932644_huf60c0187d065e5ba0272de5365118619_257690_330x0_resize_box_3.png 330w,
/basic/network/question/img/image-20230922195932644_huf60c0187d065e5ba0272de5365118619_257690_660x0_resize_box_3.png 660w,
/basic/network/question/img/image-20230922195932644_huf60c0187d065e5ba0272de5365118619_257690_1024x0_resize_box_3.png 1024w,
/basic/network/question/img/image-20230922195932644_huf60c0187d065e5ba0272de5365118619_257690_1320x0_resize_box_3.png 2x" src=/basic/network/question/img/image-20230922195932644_huf60c0187d065e5ba0272de5365118619_257690_660x0_resize_box_3.png alt></figure></p><p>再比如，客户端通过 HTTP/1.1 请求从服务器那获取到了 HTML 文件，而 HTML 可能还需要依赖 CSS 来渲染页面，这时客户端还要再发起获取 CSS 文件的请求，需要两次消息往返，如下图左边部分：</p><p><figure><img class="my-0 rounded-md" srcset="/basic/network/question/img/image-20230922195942784_hud218d471c1d084d0d56a002f76db0a9d_62485_330x0_resize_box_3.png 330w,
/basic/network/question/img/image-20230922195942784_hud218d471c1d084d0d56a002f76db0a9d_62485_660x0_resize_box_3.png 660w,
/basic/network/question/img/image-20230922195942784_hud218d471c1d084d0d56a002f76db0a9d_62485_1024x0_resize_box_3.png 1024w,
/basic/network/question/img/image-20230922195942784_hud218d471c1d084d0d56a002f76db0a9d_62485_1320x0_resize_box_3.png 2x" src=/basic/network/question/img/image-20230922195942784_hud218d471c1d084d0d56a002f76db0a9d_62485_660x0_resize_box_3.png alt></figure></p><p>如上图右边部分，在 HTTP/2 中，客户端在访问 HTML 时，服务器可以直接主动推送 CSS 文件，减少了消息传递的次数。</p><div id=19-http2-有什么缺陷 class=anchor></div><h3 class="relative group">1.9 HTTP/2 有什么缺陷
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#19-http2-%e6%9c%89%e4%bb%80%e4%b9%88%e7%bc%ba%e9%99%b7 aria-label=Anchor>#</a></span></h3><p>HTTP/2 通过 Stream 的并发能力，解决了 HTTP/1 队头阻塞的问题，看似很完美了，但是 HTTP/2 还是存在“队头阻塞”的问题，只不过问题不是在 HTTP 这一层面，而是在 TCP 这一层。</p><p><strong>HTTP/2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP/2 应用层才能从内核中拿到数据，这就是 HTTP/2 队头阻塞问题。</strong></p><p><figure><img class="my-0 rounded-md" srcset="/basic/network/question/img/image-20230922200006845_huddfe74958e2a148b577fa203cffe68cd_167268_330x0_resize_box_3.png 330w,
/basic/network/question/img/image-20230922200006845_huddfe74958e2a148b577fa203cffe68cd_167268_660x0_resize_box_3.png 660w,
/basic/network/question/img/image-20230922200006845_huddfe74958e2a148b577fa203cffe68cd_167268_1024x0_resize_box_3.png 1024w,
/basic/network/question/img/image-20230922200006845_huddfe74958e2a148b577fa203cffe68cd_167268_1320x0_resize_box_3.png 2x" src=/basic/network/question/img/image-20230922200006845_huddfe74958e2a148b577fa203cffe68cd_167268_660x0_resize_box_3.png alt></figure></p><p><figure><img class="my-0 rounded-md" srcset="/basic/network/question/img/image-20230922200018127_hu45daa9a0da14e08da3ea9ff6dab25c62_93141_330x0_resize_box_3.png 330w,
/basic/network/question/img/image-20230922200018127_hu45daa9a0da14e08da3ea9ff6dab25c62_93141_660x0_resize_box_3.png 660w,
/basic/network/question/img/image-20230922200018127_hu45daa9a0da14e08da3ea9ff6dab25c62_93141_1024x0_resize_box_3.png 1024w,
/basic/network/question/img/image-20230922200018127_hu45daa9a0da14e08da3ea9ff6dab25c62_93141_1320x0_resize_box_3.png 2x" src=/basic/network/question/img/image-20230922200018127_hu45daa9a0da14e08da3ea9ff6dab25c62_93141_660x0_resize_box_3.png alt></figure></p><p>图中发送方发送了很多个 packet，每个 packet 都有自己的序号，你可以认为是 TCP 的序列号，其中 packet 3 在网络中丢失了，即使 packet 4-6 被接收方收到后，由于内核中的 TCP 数据不是连续的，于是接收方的应用层就无法从内核中读取到，只有等到 packet 3 重传后，接收方的应用层才可以从内核中读取到数据，这就是 HTTP/2 的队头阻塞问题，是在 TCP 层面发生的。</p><p>所以，一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的<strong>所有的 HTTP 请求都必须等待这个丢了的包被重传回来</strong>。</p><div id=110-http3-做了什么优化 class=anchor></div><h3 class="relative group">1.10 HTTP/3 做了什么优化
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#110-http3-%e5%81%9a%e4%ba%86%e4%bb%80%e4%b9%88%e4%bc%98%e5%8c%96 aria-label=Anchor>#</a></span></h3><p>前面我们知道了 HTTP/1.1 和 HTTP/2 都有队头阻塞的问题：</p><ul><li>HTTP/1.1 中的管道（ pipeline）虽然解决了请求的队头阻塞，但是<strong>没有解决响应的队头阻塞</strong>，因为服务端需要按顺序响应收到的请求，如果服务端处理某个请求消耗的时间比较长，那么只能等响应完这个请求后， 才能处理下一个请求，这属于 HTTP 层队头阻塞。</li><li>HTTP/2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但是<strong>一旦发生丢包，就会阻塞住所有的 HTTP 请求</strong>，这属于 TCP 层队头阻塞。</li></ul><p>HTTP/2 队头阻塞的问题是因为 TCP，所以 <strong>HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP。</strong></p><p><figure><img class="my-0 rounded-md" srcset="/basic/network/question/img/image-20230922200115538_hu34a1d30218922c8b026dac5f21cd5b3b_201302_330x0_resize_box_3.png 330w,
/basic/network/question/img/image-20230922200115538_hu34a1d30218922c8b026dac5f21cd5b3b_201302_660x0_resize_box_3.png 660w,
/basic/network/question/img/image-20230922200115538_hu34a1d30218922c8b026dac5f21cd5b3b_201302_1024x0_resize_box_3.png 1024w,
/basic/network/question/img/image-20230922200115538_hu34a1d30218922c8b026dac5f21cd5b3b_201302_1320x0_resize_box_3.png 2x" src=/basic/network/question/img/image-20230922200115538_hu34a1d30218922c8b026dac5f21cd5b3b_201302_660x0_resize_box_3.png alt></figure></p><p>UDP 发送是不管顺序，也不管丢包的，所以不会出现像 HTTP/2 队头阻塞的问题。大家都知道 UDP 是不可靠传输的，但基于 UDP 的 <strong>QUIC 协议</strong> 可以实现类似 TCP 的可靠性传输。</p><p>QUIC 有以下 3 个特点。</p><ul><li>无队头阻塞</li><li>更快的连接建立</li><li>连接迁移</li></ul><p><strong>1.无队头阻塞</strong></p><p>QUIC 协议也有类似 HTTP/2 Stream 与多路复用的概念，也是可以在同一条连接上并发传输多个 Stream，Stream 可以认为就是一条 HTTP 请求。</p><p>QUIC 有自己的一套机制可以保证传输的可靠性的。<strong>当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题</strong>。这与 HTTP/2 不同，HTTP/2 只要某个流中的数据包丢失了，其他流也会因此受影响。</p><p>所以，QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，某个流发生丢包了，只会影响该流，其他流不受影响。</p><p><figure><img class="my-0 rounded-md" srcset="/basic/network/question/img/image-20230922200133063_hua4ae8b9333bf1087206551a43a2881d1_195011_330x0_resize_box_3.png 330w,
/basic/network/question/img/image-20230922200133063_hua4ae8b9333bf1087206551a43a2881d1_195011_660x0_resize_box_3.png 660w,
/basic/network/question/img/image-20230922200133063_hua4ae8b9333bf1087206551a43a2881d1_195011_1024x0_resize_box_3.png 1024w,
/basic/network/question/img/image-20230922200133063_hua4ae8b9333bf1087206551a43a2881d1_195011_1320x0_resize_box_3.png 2x" src=/basic/network/question/img/image-20230922200133063_hua4ae8b9333bf1087206551a43a2881d1_195011_660x0_resize_box_3.png alt></figure></p><p><strong>2.更快的连接建立</strong></p><p>对于 HTTP/1 和 HTTP/2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手，再 TLS 握手。</p><p>HTTP/3 在传输数据前虽然需要 QUIC 协议握手，但是这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。</p><p>但是 HTTP/3 的 QUIC 协议并不是与 TLS 分层，而是 QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS/1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，如下图：</p><p><figure><img class="my-0 rounded-md" srcset="/basic/network/question/img/image-20230922200217246_hue97780b717678176da13e993e26adc12_212404_330x0_resize_box_3.png 330w,
/basic/network/question/img/image-20230922200217246_hue97780b717678176da13e993e26adc12_212404_660x0_resize_box_3.png 660w,
/basic/network/question/img/image-20230922200217246_hue97780b717678176da13e993e26adc12_212404_1024x0_resize_box_3.png 1024w,
/basic/network/question/img/image-20230922200217246_hue97780b717678176da13e993e26adc12_212404_1320x0_resize_box_3.png 2x" src=/basic/network/question/img/image-20230922200217246_hue97780b717678176da13e993e26adc12_212404_660x0_resize_box_3.png alt></figure></p><p>甚至，在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。</p><p>如下图右边部分，HTTP/3 当会话恢复时，有效负载数据与第一个数据包一起发送，可以做到 0-RTT（下图的右下角）：</p><p><figure><img class="my-0 rounded-md" srcset="/basic/network/question/img/image-20230922200250401_hue81e68070ec100df757550a79658a85d_314804_330x0_resize_box_3.png 330w,
/basic/network/question/img/image-20230922200250401_hue81e68070ec100df757550a79658a85d_314804_660x0_resize_box_3.png 660w,
/basic/network/question/img/image-20230922200250401_hue81e68070ec100df757550a79658a85d_314804_1024x0_resize_box_3.png 1024w,
/basic/network/question/img/image-20230922200250401_hue81e68070ec100df757550a79658a85d_314804_1320x0_resize_box_3.png 2x" src=/basic/network/question/img/image-20230922200250401_hue81e68070ec100df757550a79658a85d_314804_660x0_resize_box_3.png alt></figure></p><p><strong>3.连接迁移</strong></p><p>基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接。</p><p><figure><img class="my-0 rounded-md" srcset="/basic/network/question/img/image-20230922200324167_hu699669f1fbdb2d54c87632d67b5db4d0_109388_330x0_resize_box_3.png 330w,
/basic/network/question/img/image-20230922200324167_hu699669f1fbdb2d54c87632d67b5db4d0_109388_660x0_resize_box_3.png 660w,
/basic/network/question/img/image-20230922200324167_hu699669f1fbdb2d54c87632d67b5db4d0_109388_1024x0_resize_box_3.png 1024w,
/basic/network/question/img/image-20230922200324167_hu699669f1fbdb2d54c87632d67b5db4d0_109388_1320x0_resize_box_3.png 2x" src=/basic/network/question/img/image-20230922200324167_hu699669f1fbdb2d54c87632d67b5db4d0_109388_660x0_resize_box_3.png alt></figure></p><p>那么<strong>当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接</strong>。而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。</p><p>而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过<strong>连接 ID</strong> 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了<strong>连接迁移</strong>的功能。</p><p>所以， QUIC 是一个在 UDP 之上的<strong>伪</strong> TCP + TLS + HTTP/2 的多路复用的协议。</p><p>QUIC 是新协议，对于很多网络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问题，因为有的网络设备是会丢掉 UDP 包的，而 QUIC 是基于 UDP 实现的，那么如果网络设备无法识别这个是 QUIC 包，那么就会当作 UDP包，然后被丢弃。</p><p>HTTP/3 现在普及的进度非常的缓慢，不知道未来 UDP 是否能够逆袭 TCP。</p><div id=111-https-和-http-相比只是传输的内容多了对称加密吗 class=anchor></div><h3 class="relative group">1.11 https 和 http 相比，只是传输的内容多了对称加密吗
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#111-https-%e5%92%8c-http-%e7%9b%b8%e6%af%94%e5%8f%aa%e6%98%af%e4%bc%a0%e8%be%93%e7%9a%84%e5%86%85%e5%ae%b9%e5%a4%9a%e4%ba%86%e5%af%b9%e7%a7%b0%e5%8a%a0%e5%af%86%e5%90%97 aria-label=Anchor>#</a></span></h3><ul><li>建立连接时候：https 比 http多了 TLS 的握手过程；</li><li>传输内容的时候：https 会把数据进行加密，通常是对称加密数据；</li></ul><div id=112-为啥-ssl-的握手是-4-次 class=anchor></div><h3 class="relative group">1.12 为啥 SSL 的握手是 4 次
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#112-%e4%b8%ba%e5%95%a5-ssl-%e7%9a%84%e6%8f%a1%e6%89%8b%e6%98%af-4-%e6%ac%a1 aria-label=Anchor>#</a></span></h3><p>SSL/TLS 1.2 需要 4 握手，需要 2 个 RTT 的时延，我文中的图是把每个交互分开画了，实际上把他们合在一起发送，就是 4 次握手：</p><p><figure><img class="my-0 rounded-md" srcset="/basic/network/question/img/image-20230922200508938_hue9ab591b6fc3b299fbddeef4c98040f4_73378_330x0_resize_box_3.png 330w,
/basic/network/question/img/image-20230922200508938_hue9ab591b6fc3b299fbddeef4c98040f4_73378_660x0_resize_box_3.png 660w,
/basic/network/question/img/image-20230922200508938_hue9ab591b6fc3b299fbddeef4c98040f4_73378_1024x0_resize_box_3.png 1024w,
/basic/network/question/img/image-20230922200508938_hue9ab591b6fc3b299fbddeef4c98040f4_73378_1320x0_resize_box_3.png 2x" src=/basic/network/question/img/image-20230922200508938_hue9ab591b6fc3b299fbddeef4c98040f4_73378_660x0_resize_box_3.png alt></figure></p><p>另外， SSL/TLS 1.3 优化了过程，只需要 1 个 RTT 往返时延，也就是只需要 3 次握手：</p><p><figure><img class="my-0 rounded-md" srcset="/basic/network/question/img/image-20230922200518223_huca8da6859746968e2e009e98c33f9564_96430_330x0_resize_box_3.png 330w,
/basic/network/question/img/image-20230922200518223_huca8da6859746968e2e009e98c33f9564_96430_660x0_resize_box_3.png 660w,
/basic/network/question/img/image-20230922200518223_huca8da6859746968e2e009e98c33f9564_96430_1024x0_resize_box_3.png 1024w,
/basic/network/question/img/image-20230922200518223_huca8da6859746968e2e009e98c33f9564_96430_1320x0_resize_box_3.png 2x" src=/basic/network/question/img/image-20230922200518223_huca8da6859746968e2e009e98c33f9564_96430_660x0_resize_box_3.png alt></figure></p><div id=113-优化-http11-协议的思路 class=anchor></div><h3 class="relative group">1.13 优化 HTTP/1.1 协议的思路
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#113-%e4%bc%98%e5%8c%96-http11-%e5%8d%8f%e8%ae%ae%e7%9a%84%e6%80%9d%e8%b7%af aria-label=Anchor>#</a></span></h3><ul><li>尽量避免发送 HTTP 请求；</li><li>在需要发送 HTTP 请求时，考虑如何减少请求次数；</li><li>减少服务器的 HTTP 响应的数据大小；</li></ul><div id=1131-如何避免发送-http-请求 class=anchor></div><h4 class="relative group">1.13.1 如何避免发送 HTTP 请求
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#1131-%e5%a6%82%e4%bd%95%e9%81%bf%e5%85%8d%e5%8f%91%e9%80%81-http-%e8%af%b7%e6%b1%82 aria-label=Anchor>#</a></span></h4><p>对于一些具有重复性的 HTTP 请求，比如每次请求得到的数据都一样的，我们可以把这对「请求-响应」的数据都<strong>缓存在本地</strong>，那么下次就直接读取本地的数据，不必在通过网络获取服务器的响应了，这样的话 HTTP/1.1 的性能肯定肉眼可见的提升。</p><p>所以，避免发送 HTTP 请求的方法就是通过<strong>缓存技术</strong>，HTTP 设计者早在之前就考虑到了这点，因此 HTTP 协议的头部有不少是针对缓存的字段。</p><p>那缓存是如何做到的呢？</p><p>客户端会把第一次请求以及响应的数据保存在本地磁盘上，其中将请求的 URL 作为 key，而响应作为 value，两者形成映射关系。</p><p>这样当后续发起相同的请求时，就可以先在本地磁盘上通过 key 查到对应的 value，也就是响应，如果找到了，就直接从本地读取该响应。毋庸置疑，读取本地磁盘的速度肯定比网络请求快得多，如下图：</p><p><figure><img class="my-0 rounded-md" srcset="/basic/network/question/img/image-20230922201816946_hub743166c94264ca00ba23c07ff123e14_316742_330x0_resize_box_3.png 330w,
/basic/network/question/img/image-20230922201816946_hub743166c94264ca00ba23c07ff123e14_316742_660x0_resize_box_3.png 660w,
/basic/network/question/img/image-20230922201816946_hub743166c94264ca00ba23c07ff123e14_316742_1024x0_resize_box_3.png 1024w,
/basic/network/question/img/image-20230922201816946_hub743166c94264ca00ba23c07ff123e14_316742_1320x0_resize_box_3.png 2x" src=/basic/network/question/img/image-20230922201816946_hub743166c94264ca00ba23c07ff123e14_316742_660x0_resize_box_3.png alt></figure></p><p>万一缓存的响应不是最新的，而客户端并不知情，那么该怎么办呢？</p><p>放心，这个问题 HTTP 设计者早已考虑到。</p><p>所以，服务器在发送 HTTP 响应时，会估算一个过期的时间，并把这个信息放到响应头部中，这样客户端在查看响应头部的信息时，一旦发现缓存的响应是过期的，则就会重新发送网络请求。</p><p>如果客户端从第一次请求得到的响应头部中发现该响应过期了，客户端重新发送请求，假设服务器上的资源并没有变更，还是老样子，那么你觉得还要在服务器的响应带上这个资源吗？</p><p>很显然不带的话，可以提高 HTTP 协议的性能，那具体如何做到呢？</p><p>只需要客户端在重新发送请求时，在请求的 <code>Etag</code> 头部带上第一次请求的响应头部中的摘要，这个摘要是唯一标识响应的资源，当服务器收到请求后，会将本地资源的摘要与请求中的摘要做个比较。</p><p>如果不同，那么说明客户端的缓存已经没有价值，服务器在响应中带上最新的资源。</p><p>如果相同，说明客户端的缓存还是可以继续使用的，那么服务器<strong>仅返回不含有包体的 <code>304 Not Modified</code> 响应</strong>，告诉客户端仍然有效，这样就可以减少响应资源在网络中传输的延时，如下图：</p><p><figure><img class="my-0 rounded-md" srcset="/basic/network/question/img/image-20230922201833683_hucce62c2c67a875263aab13c3e8145591_433920_330x0_resize_box_3.png 330w,
/basic/network/question/img/image-20230922201833683_hucce62c2c67a875263aab13c3e8145591_433920_660x0_resize_box_3.png 660w,
/basic/network/question/img/image-20230922201833683_hucce62c2c67a875263aab13c3e8145591_433920_1024x0_resize_box_3.png 1024w,
/basic/network/question/img/image-20230922201833683_hucce62c2c67a875263aab13c3e8145591_433920_1320x0_resize_box_3.png 2x" src=/basic/network/question/img/image-20230922201833683_hucce62c2c67a875263aab13c3e8145591_433920_660x0_resize_box_3.png alt></figure></p><div id=1132-如何减少-http-请求次数 class=anchor></div><h4 class="relative group">1.13.2 如何减少 HTTP 请求次数
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#1132-%e5%a6%82%e4%bd%95%e5%87%8f%e5%b0%91-http-%e8%af%b7%e6%b1%82%e6%ac%a1%e6%95%b0 aria-label=Anchor>#</a></span></h4><p>减少 HTTP 请求次数自然也就提升了 HTTP 性能，可以从这 3 个方面入手：</p><ul><li>减少重定向请求次数；</li><li>合并请求；</li><li>延迟发送请求；</li></ul><div id=1133-如何减少-http-响应数据大小 class=anchor></div><h4 class="relative group">1.13.3 如何减少 HTTP 响应数据大小
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#1133-%e5%a6%82%e4%bd%95%e5%87%8f%e5%b0%91-http-%e5%93%8d%e5%ba%94%e6%95%b0%e6%8d%ae%e5%a4%a7%e5%b0%8f aria-label=Anchor>#</a></span></h4><p>对于 HTTP 的请求和响应，通常 HTTP 的响应的数据大小会比较大，也就是服务器返回的资源会比较大。</p><p>于是，我们可以考虑对响应的资源进行<strong>压缩</strong>，这样就可以减少响应的数据大小，从而提高网络传输的效率。</p><p>压缩的方式一般分为 2 种，分别是：</p><ul><li>无损压缩；</li><li>有损压缩；</li></ul><div id=114-tls-握手过程 class=anchor></div><h3 class="relative group">1.14 TLS 握手过程
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#114-tls-%e6%8f%a1%e6%89%8b%e8%bf%87%e7%a8%8b aria-label=Anchor>#</a></span></h3><p>HTTP 由于是明文传输，所谓的明文，就是说客户端与服务端通信的信息都是肉眼可见的，随意使用一个抓包工具都可以截获通信的内容。</p><p>HTTP<strong>S</strong> 在 HTTP 与 TCP 层之间加入了 TLS 协议，来解决上述的风险。</p><ul><li>信息加密： HTTP 交互信息是被加密的，第三方就无法被窃取；</li><li>校验机制：校验信息传输过程中是否有被第三方篡改过，如果被篡改过，则会有警告提示；</li><li>身份证书：证明淘宝是真的淘宝网；</li></ul><p>在进行 HTTP 通信前，需要先进行 TLS 握手。TLS 的握手过程，如下图：</p><p><figure><img class="my-0 rounded-md" srcset="/basic/network/question/img/image-20230922202241463_hu8a5d6c614d1c604dc9f556fd6fc2ff6e_457875_330x0_resize_box_3.png 330w,
/basic/network/question/img/image-20230922202241463_hu8a5d6c614d1c604dc9f556fd6fc2ff6e_457875_660x0_resize_box_3.png 660w,
/basic/network/question/img/image-20230922202241463_hu8a5d6c614d1c604dc9f556fd6fc2ff6e_457875_1024x0_resize_box_3.png 1024w,
/basic/network/question/img/image-20230922202241463_hu8a5d6c614d1c604dc9f556fd6fc2ff6e_457875_1320x0_resize_box_3.png 2x" src=/basic/network/question/img/image-20230922202241463_hu8a5d6c614d1c604dc9f556fd6fc2ff6e_457875_660x0_resize_box_3.png alt></figure></p><p>其中每一个「框」都是一个记录（<em>record</em>），记录是 TLS 收发数据的基本单位，类似于 TCP 里的 segment。多个记录可以组合成一个 TCP 包发送，所以<strong>通常经过「四个消息」就可以完成 TLS 握手，也就是需要 2个 RTT 的时延</strong>，然后就可以在安全的通信环境里发送 HTTP 报文，实现 HTTPS 协议。</p><p>所以可以发现，HTTPS 是应用层协议，需要先完成 TCP 连接建立，然后走 TLS 握手过程后，才能建立通信安全的连接。</p><p>事实上，不同的密钥交换算法，TLS 的握手过程可能会有一些区别。</p><p>这里先简单介绍下密钥交换算法，因为考虑到性能的问题，所以双方在加密应用信息时使用的是对称加密密钥，而对称加密密钥是不能被泄漏的，为了保证对称加密密钥的安全性，所以使用非对称加密的方式来保护对称加密密钥的协商，这个工作就是密钥交换算法负责的。</p><p>接下来，以最简单的 <code>RSA</code> 密钥交换算法，来看看它的 TLS 握手过程。</p><div id=115-rsa-握手过程 class=anchor></div><h3 class="relative group">1.15 RSA 握手过程
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#115-rsa-%e6%8f%a1%e6%89%8b%e8%bf%87%e7%a8%8b aria-label=Anchor>#</a></span></h3><p>传统的 TLS 握手基本都是使用 RSA 算法来实现密钥交换的，在将 TLS 证书部署服务端时，证书文件其实就是服务端的公钥，会在 TLS 握手阶段传递给客户端，而服务端的私钥则一直留在服务端，一定要确保私钥不能被窃取。</p><p>在 RSA 密钥协商算法中，客户端会生成随机密钥，并使用服务端的公钥加密后再传给服务端。根据非对称加密算法，公钥加密的消息仅能通过私钥解密，这样服务端解密后，双方就得到了相同的密钥，再用它加密应用消息。</p><p>我用 Wireshark 工具抓了用 RSA 密钥交换的 TLS 握手过程，你可以从下面看到，一共经历了四次握手：</p><p><figure><img class="my-0 rounded-md" srcset="/basic/network/question/img/image-20230922202449228_huab68c9e93172a7cc1e59616ce2f03177_391905_330x0_resize_box_3.png 330w,
/basic/network/question/img/image-20230922202449228_huab68c9e93172a7cc1e59616ce2f03177_391905_660x0_resize_box_3.png 660w,
/basic/network/question/img/image-20230922202449228_huab68c9e93172a7cc1e59616ce2f03177_391905_1024x0_resize_box_3.png 1024w,
/basic/network/question/img/image-20230922202449228_huab68c9e93172a7cc1e59616ce2f03177_391905_1320x0_resize_box_3.png 2x" src=/basic/network/question/img/image-20230922202449228_huab68c9e93172a7cc1e59616ce2f03177_391905_660x0_resize_box_3.png alt></figure></p><p>对应 Wireshark 的抓包，从下图很清晰地看到该过程：</p><p><figure><img class="my-0 rounded-md" srcset="/basic/network/question/img/image-20230922202503060_hu5102839c0ca57975b3e01bbc5fbe3361_1430195_330x0_resize_box_3.png 330w,
/basic/network/question/img/image-20230922202503060_hu5102839c0ca57975b3e01bbc5fbe3361_1430195_660x0_resize_box_3.png 660w,
/basic/network/question/img/image-20230922202503060_hu5102839c0ca57975b3e01bbc5fbe3361_1430195_1024x0_resize_box_3.png 1024w,
/basic/network/question/img/image-20230922202503060_hu5102839c0ca57975b3e01bbc5fbe3361_1430195_1320x0_resize_box_3.png 2x" src=/basic/network/question/img/image-20230922202503060_hu5102839c0ca57975b3e01bbc5fbe3361_1430195_660x0_resize_box_3.png alt></figure></p><div id=1151-tls-第一次握手 class=anchor></div><h4 class="relative group">1.15.1 TLS 第一次握手
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#1151-tls-%e7%ac%ac%e4%b8%80%e6%ac%a1%e6%8f%a1%e6%89%8b aria-label=Anchor>#</a></span></h4><p>客户端首先会发一个「<strong>Client Hello</strong>」消息，字面意思我们也能理解到，这是跟服务器「打招呼」。</p><p><figure><img class="my-0 rounded-md" srcset="/basic/network/question/img/image-20230922202535348_hu78f4ed9fbe2f7999f65c9bd32b1fe9a9_185328_330x0_resize_box_3.png 330w,
/basic/network/question/img/image-20230922202535348_hu78f4ed9fbe2f7999f65c9bd32b1fe9a9_185328_660x0_resize_box_3.png 660w,
/basic/network/question/img/image-20230922202535348_hu78f4ed9fbe2f7999f65c9bd32b1fe9a9_185328_1024x0_resize_box_3.png 1024w,
/basic/network/question/img/image-20230922202535348_hu78f4ed9fbe2f7999f65c9bd32b1fe9a9_185328_1320x0_resize_box_3.png 2x" src=/basic/network/question/img/image-20230922202535348_hu78f4ed9fbe2f7999f65c9bd32b1fe9a9_185328_660x0_resize_box_3.png alt></figure></p><p>消息里面有客户端使用的 TLS 版本号、支持的密码套件列表，以及生成的<strong>随机数（<em>Client Random</em>）</strong>，这个随机数会被服务端保留，它是生成对称加密密钥的材料之一。</p><div id=1152-tls-第二次握手 class=anchor></div><h4 class="relative group">1.15.2 TLS 第二次握手
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#1152-tls-%e7%ac%ac%e4%ba%8c%e6%ac%a1%e6%8f%a1%e6%89%8b aria-label=Anchor>#</a></span></h4><p>当服务端收到客户端的「Client Hello」消息后，会确认 TLS 版本号是否支持，和从密码套件列表中选择一个密码套件，以及生成<strong>随机数（<em>Server Random</em>）</strong>。</p><p>接着，返回「<strong>Server Hello</strong>」消息，消息里面有服务器确认的 TLS 版本号，也给出了随机数（Server Random），然后从客户端的密码套件列表选择了一个合适的密码套件。</p><p><figure><img class="my-0 rounded-md" srcset="/basic/network/question/img/image-20230922202617100_hu691bb02ebd5bd2ed9a029f42d0bafb28_149672_330x0_resize_box_3.png 330w,
/basic/network/question/img/image-20230922202617100_hu691bb02ebd5bd2ed9a029f42d0bafb28_149672_660x0_resize_box_3.png 660w,
/basic/network/question/img/image-20230922202617100_hu691bb02ebd5bd2ed9a029f42d0bafb28_149672_1024x0_resize_box_3.png 1024w,
/basic/network/question/img/image-20230922202617100_hu691bb02ebd5bd2ed9a029f42d0bafb28_149672_1320x0_resize_box_3.png 2x" src=/basic/network/question/img/image-20230922202617100_hu691bb02ebd5bd2ed9a029f42d0bafb28_149672_660x0_resize_box_3.png alt></figure></p><p>可以看到，服务端选择的密码套件是 “Cipher Suite: TLS_RSA_WITH_AES_128_GCM_SHA256”。</p><p>这个密码套件看起来真让人头晕，好一大串，但是其实它是有固定格式和规范的。基本的形式是「<strong>密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法</strong>」， 一般 WITH 单词前面有两个单词，第一个单词是约定密钥交换的算法，第二个单词是约定证书的验证算法。比如刚才的密码套件的意思就是：</p><ul><li>由于 WITH 单词只有一个 RSA，则说明握手时密钥交换算法和签名算法都是使用 RSA；</li><li>握手后的通信使用 AES 对称算法，密钥长度 128 位，分组模式是 GCM；</li><li>摘要算法 SHA256 用于消息认证和产生随机数；</li></ul><p>就前面这两个客户端和服务端相互「打招呼」的过程，客户端和服务端就已确认了 TLS 版本和使用的密码套件，而且你可能发现客户端和服务端都会各自生成一个随机数，并且还会把随机数传递给对方。</p><p>那这个随机数有啥用呢？其实这两个随机数是后续作为生成「会话密钥」的条件，所谓的会话密钥就是数据传输时，所使用的对称加密密钥。</p><p>然后，服务端为了证明自己的身份，会发送「<strong>Server Certificate</strong>」给客户端，这个消息里含有数字证书。</p><p><figure><img class="my-0 rounded-md" srcset="/basic/network/question/img/image-20230922202628665_huefbffbc28923a97636ceefbbc170b59c_74425_330x0_resize_box_3.png 330w,
/basic/network/question/img/image-20230922202628665_huefbffbc28923a97636ceefbbc170b59c_74425_660x0_resize_box_3.png 660w,
/basic/network/question/img/image-20230922202628665_huefbffbc28923a97636ceefbbc170b59c_74425_1024x0_resize_box_3.png 1024w,
/basic/network/question/img/image-20230922202628665_huefbffbc28923a97636ceefbbc170b59c_74425_1320x0_resize_box_3.png 2x" src=/basic/network/question/img/image-20230922202628665_huefbffbc28923a97636ceefbbc170b59c_74425_660x0_resize_box_3.png alt></figure></p><p>随后，服务端发了「<strong>Server Hello Done</strong>」消息，目的是告诉客户端，我已经把该给你的东西都给你了，本次打招呼完毕。</p><p><figure><img class="my-0 rounded-md" srcset="/basic/network/question/img/image-20230922202635930_hu9a53d8aa0e0792680cc21ab5e9709449_36966_330x0_resize_box_3.png 330w,
/basic/network/question/img/image-20230922202635930_hu9a53d8aa0e0792680cc21ab5e9709449_36966_660x0_resize_box_3.png 660w,
/basic/network/question/img/image-20230922202635930_hu9a53d8aa0e0792680cc21ab5e9709449_36966_1024x0_resize_box_3.png 1024w,
/basic/network/question/img/image-20230922202635930_hu9a53d8aa0e0792680cc21ab5e9709449_36966_1320x0_resize_box_3.png 2x" src=/basic/network/question/img/image-20230922202635930_hu9a53d8aa0e0792680cc21ab5e9709449_36966_660x0_resize_box_3.png alt></figure></p><p>客户端拿到了服务端的数字证书后，对数字证书进行校验。</p><div id=1153-tls-第三次握手 class=anchor></div><h4 class="relative group">1.15.3 TLS 第三次握手
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#1153-tls-%e7%ac%ac%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b aria-label=Anchor>#</a></span></h4><p>客户端验证完证书后，认为可信则继续往下走。</p><p>接着，客户端就会生成一个新的<strong>随机数 (<em>pre-master</em>)</strong>，用服务器的 RSA 公钥加密该随机数，通过「<strong>Client Key Exchange</strong>」消息传给服务端。</p><p><figure><img class="my-0 rounded-md" srcset="/basic/network/question/img/image-20230922202809442_hue3ea335590fb55900b859f5a09ae01d6_96659_330x0_resize_box_3.png 330w,
/basic/network/question/img/image-20230922202809442_hue3ea335590fb55900b859f5a09ae01d6_96659_660x0_resize_box_3.png 660w,
/basic/network/question/img/image-20230922202809442_hue3ea335590fb55900b859f5a09ae01d6_96659_1024x0_resize_box_3.png 1024w,
/basic/network/question/img/image-20230922202809442_hue3ea335590fb55900b859f5a09ae01d6_96659_1320x0_resize_box_3.png 2x" src=/basic/network/question/img/image-20230922202809442_hue3ea335590fb55900b859f5a09ae01d6_96659_660x0_resize_box_3.png alt></figure></p><p>服务端收到后，用 RSA 私钥解密，得到客户端发来的随机数 (pre-master)。</p><p>至此，<strong>客户端和服务端双方都共享了三个随机数，分别是 Client Random、Server Random、pre-master</strong>。</p><p>于是，双方根据已经得到的三个随机数，生成<strong>会话密钥（Master Secret）</strong>，它是对称密钥，用于对后续的 HTTP 请求/响应的数据加解密。</p><p>生成完「会话密钥」后，然后客户端发一个「<strong>Change Cipher Spec</strong>」，告诉服务端开始使用加密方式发送消息。</p><p><figure><img class="my-0 rounded-md" srcset="/basic/network/question/img/image-20230922202820331_hu3989e4f6e2dd0cd742ae3697740b251d_39491_330x0_resize_box_3.png 330w,
/basic/network/question/img/image-20230922202820331_hu3989e4f6e2dd0cd742ae3697740b251d_39491_660x0_resize_box_3.png 660w,
/basic/network/question/img/image-20230922202820331_hu3989e4f6e2dd0cd742ae3697740b251d_39491_1024x0_resize_box_3.png 1024w,
/basic/network/question/img/image-20230922202820331_hu3989e4f6e2dd0cd742ae3697740b251d_39491_1320x0_resize_box_3.png 2x" src=/basic/network/question/img/image-20230922202820331_hu3989e4f6e2dd0cd742ae3697740b251d_39491_660x0_resize_box_3.png alt></figure></p><p>可以发现，「Change Cipher Spec」之前传输的 TLS 握手数据都是明文，之后都是对称密钥加密的密文。</p><div id=1154-tls-第四次握手 class=anchor></div><h4 class="relative group">1.15.4 TLS 第四次握手
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#1154-tls-%e7%ac%ac%e5%9b%9b%e6%ac%a1%e6%8f%a1%e6%89%8b aria-label=Anchor>#</a></span></h4><p>服务器也是同样的操作，发「<strong>Change Cipher Spec</strong>」和「<strong>Encrypted Handshake Message</strong>」消息，如果双方都验证加密和解密没问题，那么握手正式完成。</p><p>最后，就用「会话密钥」加解密 HTTP 请求和响应了。</p><div id=116-rsa-算法的缺陷 class=anchor></div><h3 class="relative group">1.16 RSA 算法的缺陷
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#116-rsa-%e7%ae%97%e6%b3%95%e7%9a%84%e7%bc%ba%e9%99%b7 aria-label=Anchor>#</a></span></h3><p><strong>使用 RSA 密钥协商算法的最大问题是不支持前向保密</strong>。</p><p>因为客户端传递随机数（用于生成对称加密密钥的条件之一）给服务端时使用的是公钥加密的，服务端收到后，会用私钥解密得到随机数。所以一旦服务端的私钥泄漏了，过去被第三方截获的所有 TLS 通讯密文都会被破解。</p><p>为了解决这个问题，后面就出现了 ECDHE 密钥协商算法，我们现在大多数网站使用的正是 ECDHE 密钥协商算法。</p><div id=117-https-如何优化 class=anchor></div><h3 class="relative group">1.17 HTTPS 如何优化
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#117-https-%e5%a6%82%e4%bd%95%e4%bc%98%e5%8c%96 aria-label=Anchor>#</a></span></h3><p>由裸数据传输的 HTTP 协议转成加密数据传输的 HTTPS 协议，给应用数据套了个「保护伞」，提高安全性的同时也带来了性能消耗。</p><p>因为 HTTPS 相比 HTTP 协议多一个 TLS 协议握手过程，<strong>目的是为了通过非对称加密握手协商或者交换出对称加密密钥</strong>，这个过程最长可以花费掉 2 RTT，接着后续传输的应用数据都得使用对称加密密钥来加密/解密。</p><p><strong>产生性能消耗</strong>的两个环节：</p><ul><li>第一个环节， TLS 协议握手过程；</li><li>第二个环节，握手后的对称加密报文传输。</li></ul><p>对于第二环节，现在主流的对称加密算法 AES、ChaCha20 性能都是不错的，而且一些 CPU 厂商还针对它们做了硬件级别的优化，因此这个环节的性能消耗可以说非常地小。</p><p>而第一个环节，TLS 协议握手过程不仅增加了网络延时（最长可以花费掉 2 RTT），而且握手过程中的一些步骤也会产生性能损耗，比如：</p><ul><li>对于 ECDHE 密钥协商算法，握手过程中会客户端和服务端都需要临时生成椭圆曲线公私钥；</li><li>客户端验证证书时，会访问 CA 获取 CRL 或者 OCSP，目的是验证服务器的证书是否有被吊销；</li><li>双方计算 Pre-Master，也就是对称加密密钥；</li></ul><p><figure><img class="my-0 rounded-md" srcset="/basic/network/question/img/image-20230922203255557_hue64606e1156a5156831bc28035f08d22_610850_330x0_resize_box_3.png 330w,
/basic/network/question/img/image-20230922203255557_hue64606e1156a5156831bc28035f08d22_610850_660x0_resize_box_3.png 660w,
/basic/network/question/img/image-20230922203255557_hue64606e1156a5156831bc28035f08d22_610850_1024x0_resize_box_3.png 1024w,
/basic/network/question/img/image-20230922203255557_hue64606e1156a5156831bc28035f08d22_610850_1320x0_resize_box_3.png 2x" src=/basic/network/question/img/image-20230922203255557_hue64606e1156a5156831bc28035f08d22_610850_660x0_resize_box_3.png alt></figure></p><div id=1171-硬件优化 class=anchor></div><h4 class="relative group">1.17.1 硬件优化
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#1171-%e7%a1%ac%e4%bb%b6%e4%bc%98%e5%8c%96 aria-label=Anchor>#</a></span></h4><p><strong>HTTPS 协议是计算密集型，而不是 I/O 密集型</strong>，所以不能把钱花在网卡、硬盘等地方，应该花在 CPU 上。</p><p>一个好的 CPU，可以提高计算性能，因为 HTTPS 连接过程中就有大量需要计算密钥的过程，所以这样可以加速 TLS 握手过程。</p><p>另外，如果可以，应该选择可以<strong>支持 AES-NI 特性的 CPU</strong>，因为这种款式的 CPU 能在指令级别优化了 AES 算法，这样便加速了数据的加解密传输过程。</p><p>如果我们的 CPU 支持 AES-NI 特性，那么对于对称加密的算法应该选择 AES 算法。否则可以选择 ChaCha20 对称加密算法，因为 ChaCha20 算法的运算指令相比 AES 算法会对 CPU 更友好一点。</p><div id=1172-软件优化 class=anchor></div><h4 class="relative group">1.17.2 软件优化
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#1172-%e8%bd%af%e4%bb%b6%e4%bc%98%e5%8c%96 aria-label=Anchor>#</a></span></h4><p>软件升级就是将正在使用的软件升级到最新版本，因为最新版本不仅提供了最新的特性，也优化了以前软件的问题或性能。比如：</p><ul><li>将 Linux 内核从 2.x 升级到 4.x；</li><li>将 OpenSSL 从 1.0.1 升级到 1.1.1；</li></ul><div id=1173-协议优化 class=anchor></div><h4 class="relative group">1.17.3 协议优化
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#1173-%e5%8d%8f%e8%ae%ae%e4%bc%98%e5%8c%96 aria-label=Anchor>#</a></span></h4><p>协议的优化就是对「密钥交换过程」进行优化。</p><p><strong>密钥交换算法优化</strong></p><p>TLS 1.2 版本如果使用的是 RSA 密钥交换算法，那么需要 4 次握手，也就是要花费 2 RTT，才可以进行应用数据的传输，而且 RSA 密钥交换算法不具备前向安全性。</p><p>总之使用 <strong>RSA 密钥交换算法的 TLS 握手过程，不仅慢，而且安全性也不高</strong>。</p><p>因此如果可以，尽量<strong>选用 ECDHE 密钥交换</strong>算法替换 RSA 算法，因为该算法由于支持「False Start」，它是“抢跑”的意思，客户端可以在 TLS 协议的第 3 次握手后，第 4 次握手前，发送加密的应用数据，以此将 <strong>TLS 握手的消息往返由 2 RTT 减少到 1 RTT，而且安全性也高，具备前向安全性</strong>。</p><p>ECDHE 算法是基于椭圆曲线实现的，不同的椭圆曲线性能也不同，应该尽量<strong>选择 x25519 曲线</strong>，该曲线是目前最快的椭圆曲线。</p><p>对于对称加密算法方面，如果对安全性不是特别高的要求，可以<strong>选用 AES_128_GCM</strong>，它比 AES_256_GCM 快一些，因为密钥的长度短一些。</p><p>比如在 Nginx 上，可以使用 ssl_ciphers 指令配置想使用的非对称加密算法和对称加密算法，也就是密钥套件，而且把性能最快最安全的算法放在最前面。</p><p><strong>TLS 升级</strong></p><p>如果可以，直接把 TLS 1.2 升级成 TLS 1.3，TLS 1.3 大幅度简化了握手的步骤，<strong>完成 TLS 握手只要 1 RTT</strong>，而且安全性更高。</p><p>在 TLS 1.2 的握手中，一般是需要 4 次握手，先要通过 Client Hello （第 1 次握手）和 Server Hello（第 2 次握手） 消息协商出后续使用的加密算法，再互相交换公钥（第 3 和 第 4 次握手），然后计算出最终的会话密钥，下图的左边部分就是 TLS 1.2 的握手过程：</p><p><figure><img class="my-0 rounded-md" srcset="/basic/network/question/img/image-20230922203547911_hucd47f39e8a40cf5f6ca91a93d8ebc90a_880977_330x0_resize_box_3.png 330w,
/basic/network/question/img/image-20230922203547911_hucd47f39e8a40cf5f6ca91a93d8ebc90a_880977_660x0_resize_box_3.png 660w,
/basic/network/question/img/image-20230922203547911_hucd47f39e8a40cf5f6ca91a93d8ebc90a_880977_1024x0_resize_box_3.png 1024w,
/basic/network/question/img/image-20230922203547911_hucd47f39e8a40cf5f6ca91a93d8ebc90a_880977_1320x0_resize_box_3.png 2x" src=/basic/network/question/img/image-20230922203547911_hucd47f39e8a40cf5f6ca91a93d8ebc90a_880977_660x0_resize_box_3.png alt></figure></p><p>上图的右边部分就是 TLS 1.3 的握手过程，可以发现 <strong>TLS 1.3 把 Hello 和公钥交换这两个消息合并成了一个消息，于是这样就减少到只需 1 RTT 就能完成 TLS 握手</strong>。</p><p>怎么合并的呢？具体的做法是，客户端在 Client Hello 消息里带上了支持的椭圆曲线，以及这些椭圆曲线对应的公钥。</p><p>服务端收到后，选定一个椭圆曲线等参数，然后返回消息时，带上服务端这边的公钥。经过这 1 个 RTT，双方手上已经有生成会话密钥的材料了，于是客户端计算出会话密钥，就可以进行应用数据的加密传输了。</p><p>而且，TLS1.3 对密码套件进行“减肥”了， <strong>对于密钥交换算法，废除了不支持前向安全性的 RSA 和 DH 算法，只支持 ECDHE 算法</strong>。</p><div id=1174-证书优化 class=anchor></div><h4 class="relative group">1.17.4 证书优化
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#1174-%e8%af%81%e4%b9%a6%e4%bc%98%e5%8c%96 aria-label=Anchor>#</a></span></h4><p>为了验证的服务器的身份，服务器会在 TLS 握手过程中，把自己的证书发给客户端，以此证明自己身份是可信的。</p><p>对于证书的优化，可以有两个方向：</p><ul><li>一个是<strong>证书传输</strong>：要让证书更便于传输，那必然是减少证书的大小，这样可以节约带宽，也能减少客户端的运算量。所以，<strong>对于服务器的证书应该选择椭圆曲线（ECDSA）证书，而不是 RSA 证书，因为在相同安全强度下， ECC 密钥长度比 RSA 短的多</strong>。</li><li>一个是<strong>证书验证</strong>：客户端在验证证书时，是个复杂的过程，会走证书链逐级验证，验证的过程不仅需要「用 CA 公钥解密证书」以及「用签名算法验证证书的完整性」，而且为了知道证书是否被 CA 吊销，客户端有时还会再去访问 CA， 下载 CRL 或者 OCSP 数据，以此确认证书的有效性。</li></ul><div id=1175-会话复用 class=anchor></div><h4 class="relative group">1.17.5 会话复用
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#1175-%e4%bc%9a%e8%af%9d%e5%a4%8d%e7%94%a8 aria-label=Anchor>#</a></span></h4><p>TLS 握手的目的就是为了协商出会话密钥，也就是对称加密密钥，那我们如果我们把首次 TLS 握手协商的对称加密密钥缓存起来，待下次需要建立 HTTPS 连接时，直接「复用」这个密钥，不就减少 TLS 握手的性能损耗了吗？</p><p>这种方式就是<strong>会话复用</strong>（<em>TLS session resumption</em>），会话复用分两种：</p><ul><li>第一种叫 Session ID；</li><li>第二种叫 Session Ticket；</li><li>还有一种 Pre-shared Key；</li></ul><p><strong>Session ID</strong></p><p>Session ID 的工作原理是，<strong>客户端和服务器首次 TLS 握手连接后，双方会在内存缓存会话密钥，并用唯一的 Session ID 来标识</strong>，Session ID 和会话密钥相当于 key-value 的关系。</p><p>当客户端再次连接时，hello 消息里会带上 Session ID，服务器收到后就会从内存找，如果找到就直接用该会话密钥恢复会话状态，跳过其余的过程，只用一个消息往返就可以建立安全通信。当然为了安全性，内存中的会话密钥会定期失效。</p><p><strong>Session Ticket</strong></p><p>为了解决 Session ID 的问题，就出现了 Session Ticket，<strong>服务器不再缓存每个客户端的会话密钥，而是把缓存的工作交给了客户端</strong>，类似于 HTTP 的 Cookie。</p><p>客户端与服务器首次建立连接时，服务器会加密「会话密钥」作为 Ticket 发给客户端，交给客户端缓存该 Ticket。</p><p>客户端再次连接服务器时，客户端会发送 Ticket，服务器解密后就可以获取上一次的会话密钥，然后验证有效期，如果没问题，就可以恢复会话了，开始加密通信。</p><p>对于集群服务器的话，<strong>要确保每台服务器加密 「会话密钥」的密钥是一致的</strong>，这样客户端携带 Ticket 访问任意一台服务器时，都能恢复会话。</p><p>Session ID 和 Session Ticket <strong>都不具备前向安全性</strong>，因为一旦加密「会话密钥」的密钥被破解或者服务器泄漏「会话密钥」，前面劫持的通信密文都会被破解。</p><p><strong>Pre-shared Key</strong></p><p>前面的 Session ID 和 Session Ticket 方式都需要在 1 RTT 才能恢复会话。</p><p>而 TLS1.3 更为牛逼，对于重连 TLS1.3 只需要 <strong>0 RTT</strong>，原理和 Ticket 类似，只不过在重连时，客户端会把 Ticket 和 HTTP 请求一同发送给服务端，这种方式叫 <strong>Pre-shared Key</strong>。</p><p><figure><img class="my-0 rounded-md" srcset="/basic/network/question/img/image-20230922204015849_hu42a8fd0faccebc03784e290f9107ad5e_165016_330x0_resize_box_3.png 330w,
/basic/network/question/img/image-20230922204015849_hu42a8fd0faccebc03784e290f9107ad5e_165016_660x0_resize_box_3.png 660w,
/basic/network/question/img/image-20230922204015849_hu42a8fd0faccebc03784e290f9107ad5e_165016_1024x0_resize_box_3.png 1024w,
/basic/network/question/img/image-20230922204015849_hu42a8fd0faccebc03784e290f9107ad5e_165016_1320x0_resize_box_3.png 2x" src=/basic/network/question/img/image-20230922204015849_hu42a8fd0faccebc03784e290f9107ad5e_165016_660x0_resize_box_3.png alt></figure></p><div id=2tcp class=anchor></div><h2 class="relative group">2.TCP
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#2tcp aria-label=Anchor>#</a></span></h2></div></div><script>var oid="views_basic/network/question/index.md",oid_likes="likes_basic/network/question/index.md"</script><script type=text/javascript src=/js/page.min.0e49973b4ad0a382c7c6012d8bff8226316642daabc4f8a20477bd08674f3da6e2fa993bc20ad4f51e7c5bb68e6f913a207a7c4fe37ea0e7b806894afce0a64e.js integrity="sha512-DkmXO0rQo4LHxgEti/+CJjFmQtqrxPiiBHe9CGdPPabi+pk7wgrU9R58W7aOb5E6IHp8T+N+oOe4BolK/OCmTg=="></script></section><footer class="pt-8 max-w-prose print:hidden"><div class=pt-8><hr class="border-dotted border-neutral-300 dark:border-neutral-600"><div class="flex justify-between pt-3"><span></span><span><a class="flex text-right group ml-3" href=/basic/mysql/review/03/><span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">MySQL 事务</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"><time datetime="2023-09-22 13:08:15 +0800 +0800">22 September 2023</time></span></span>
<span class="ml-3 text-neutral-700 group-hover:text-primary-600 ltr:inline rtl:hidden dark:text-neutral dark:group-hover:text-primary-400">&rarr;</span>
<span class="mr-3 text-neutral-700 group-hover:text-primary-600 ltr:hidden rtl:inline dark:text-neutral dark:group-hover:text-primary-400">&larr;</span></a></span></div></div></footer></article><div id=top-scroller class="pointer-events-none absolute top-[110vh] bottom-0 w-12 ltr:right-0 rtl:left-0"><a href=#the-top class="pointer-events-auto sticky top-[calc(100vh-5.5rem)] flex h-12 w-12 mb-16 items-center justify-center rounded-full bg-neutral/50 text-xl text-neutral-700 backdrop-blur hover:text-primary-600 dark:bg-neutral-800/50 dark:text-neutral dark:hover:text-primary-400" aria-label="Scroll to top" title="Scroll to top">&uarr;</a></div></main><footer id=site-footer class="py-10 print:hidden"><div class="flex items-center justify-between"><p class="text-sm text-neutral-500 dark:text-neutral-400">&copy;
2023</p></div><script>mediumZoom(document.querySelectorAll("img:not(.nozoom)"),{margin:24,background:"rgba(0,0,0,0.5)",scrollOffset:0})</script><script type=text/javascript src=/js/process.min.35c1113bcc16c5a59bf031082f9e63822aa95280423881a7847a7ff33a16e6299ce6a840d9ef4e10d947e030a18f3f20359afb2ec0f35967484b9a9360ac3145.js integrity="sha512-NcERO8wWxaWb8DEIL55jgiqpUoBCOIGnhHp/8zoW5imc5qhA2e9OENlH4DChjz8gNZr7LsDzWWdIS5qTYKwxRQ=="></script></footer><div id=search-wrapper class="invisible fixed inset-0 flex h-screen w-screen cursor-default flex-col bg-neutral-500/50 p-4 backdrop-blur-sm dark:bg-neutral-900/50 sm:p-6 md:p-[10vh] lg:p-[12vh]" data-url=https://newtsun.github.io style=z-index:500><div id=search-modal class="flex flex-col w-full max-w-3xl min-h-0 mx-auto border rounded-md shadow-lg top-20 border-neutral-200 bg-neutral dark:border-neutral-700 dark:bg-neutral-800"><header class="relative z-10 flex items-center justify-between flex-none px-2"><form class="flex items-center flex-auto min-w-0"><div class="flex items-center justify-center w-8 h-8 text-neutral-400"><span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></div><input type=search id=search-query class="flex flex-auto h-12 mx-1 bg-transparent appearance-none focus:outline-dotted focus:outline-2 focus:outline-transparent" placeholder=Search tabindex=0></form><button id=close-search-button class="flex items-center justify-center w-8 h-8 text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400" title="Close (Esc)">
<span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path fill="currentcolor" d="M310.6 361.4c12.5 12.5 12.5 32.75.0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3 54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75.0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75.0-45.25s32.75-12.5 45.25.0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25.0s12.5 32.75.0 45.25l-105.4 105.4L310.6 361.4z"/></svg></span></button></header><section class="flex-auto px-2 overflow-auto"><ul id=search-results></ul></section></div></div></div></body></html>
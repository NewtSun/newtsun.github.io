<!doctype html><html lang=en dir=ltr class=scroll-smooth data-default-appearance=dark data-auto-appearance=true><head><meta charset=utf-8><meta http-equiv=content-language content="en"><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><title>Redis 基础 &#183; NewtSun</title><meta name=title content="Redis 基础 &#183; NewtSun"><meta name=keywords content="Redis,review,"><link rel=canonical href=https://newtsun.github.io/basic/redis/review/01/><link type=text/css rel=stylesheet href=/css/main.bundle.min.24be37d0eaaebe41c52830ebd6674e9b0772d04c4acf37449ca01896e7adb1599d52a071142e7525f3054f3da0c0aae69065d64bfe59b713d4e8d235fe3c1d54.css integrity="sha512-JL430OquvkHFKDDr1mdOmwdy0ExKzzdEnKAYluetsVmdUqBxFC51JfMFTz2gwKrmkGXWS/5ZtxPU6NI1/jwdVA=="><script type=text/javascript src=/js/appearance.min.516a16745bea5a9bd011138d254cc0fd3973cd55ce6e15f3dec763e7c7c2c7448f8fe7b54cca811cb821b0c7e12cd161caace1dd794ac3d34d40937cbcc9ee12.js integrity="sha512-UWoWdFvqWpvQERONJUzA/TlzzVXObhXz3sdj58fCx0SPj+e1TMqBHLghsMfhLNFhyqzh3XlKw9NNQJN8vMnuEg=="></script>
<script defer type=text/javascript id=script-bundle src=/js/main.bundle.min.3ddcf04f5b0d4c32f72e726d3c12eebccd8c3c9f9daa9a13414808895de0ae1e1cdddda6849680d5bd96dbb60d0b1e0b24c29f5c83e5631e55e7e6bc02015490.js integrity="sha512-PdzwT1sNTDL3LnJtPBLuvM2MPJ+dqpoTQUgIiV3grh4c3d2mhJaA1b2W27YNCx4LJMKfXIPlYx5V5+a8AgFUkA==" data-copy data-copied></script>
<script src=/js/zoom.min.js></script>
<link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta property="og:title" content="Redis 基础"><meta property="og:description" content="Redis 相关知识复习"><meta property="og:type" content="article"><meta property="og:url" content="https://newtsun.github.io/basic/redis/review/01/"><meta property="og:image" content="https://newtsun.github.io/basic/redis/review/01/feature.jpg"><meta property="article:section" content="basic"><meta property="article:published_time" content="2023-09-21T15:29:38+08:00"><meta property="article:modified_time" content="2023-09-21T15:29:38+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://newtsun.github.io/basic/redis/review/01/feature.jpg"><meta name=twitter:title content="Redis 基础"><meta name=twitter:description content="Redis 相关知识复习"><script type=application/ld+json>[{"@context":"https://schema.org","@type":"Article","articleSection":"Basics","name":"Redis 基础","headline":"Redis 基础","abstract":"Redis 相关知识复习","inLanguage":"en","url":"https:\/\/newtsun.github.io\/basic\/redis\/review\/01\/","author":{"@type":"Person","name":""},"copyrightYear":"2023","dateCreated":"2023-09-21T15:29:38\u002b08:00","datePublished":"2023-09-21T15:29:38\u002b08:00","dateModified":"2023-09-21T15:29:38\u002b08:00","keywords":["Redis","review"],"mainEntityOfPage":"true","wordCount":"1382"}]</script><script src=/lib/jquery/jquery.slim.min.js integrity></script><meta name=theme-color></head><body class="flex flex-col h-screen px-6 m-auto text-lg leading-7 max-w-7xl bg-neutral text-neutral-900 dark:bg-neutral-800 dark:text-neutral sm:px-14 md:px-24 lg:px-32"><div id=the-top class="absolute flex self-center"><a class="px-3 py-1 text-sm -translate-y-8 rounded-b-lg bg-primary-200 focus:translate-y-0 dark:bg-neutral-600" href=#main-content><span class="font-bold text-primary-600 ltr:pr-2 rtl:pl-2 dark:text-primary-400">&darr;</span>Skip to main content</a></div><div class=min-h-[148px]></div><div class="fixed inset-x-0 pl-[24px] pr-[24px]" style=z-index:100><div id=menu-blur class="absolute opacity-0 inset-x-0 top-0 h-full single_hero_background nozoom backdrop-blur-2xl shadow-2xl"></div><div class="relative max-w-[64rem] ml-auto mr-auto"><div style=padding-left:0;padding-right:0;padding-top:2px;padding-bottom:3px class="main-menu flex items-center justify-between px-4 py-6 sm:px-6 md:justify-start space-x-3"><div class="flex flex-1 items-center justify-between"><nav class="flex space-x-3"><a href=/ class="text-base font-medium text-gray-500 hover:text-gray-900">NewtSun</a></nav><nav class="hidden md:flex items-center space-x-5 md:ml-12 h-12"><a href=/golang/ class="flex items-center"><p class="text-base font-medium text-gray-500 hover:text-gray-900" title=Golang>Golang</p></a><a href=/python/ class="flex items-center"><p class="text-base font-medium text-gray-500 hover:text-gray-900" title=Pythons>Python</p></a><a href=/linux/ class="flex items-center"><p class="text-base font-medium text-gray-500 hover:text-gray-900" title=Linuxes>Linux</p></a><a href=/basic/ class="flex items-center"><p class="text-base font-medium text-gray-500 hover:text-gray-900" title=Basics>Basic</p></a><a href=/cloud/ class="flex items-center"><p class="text-base font-medium text-gray-500 hover:text-gray-900" title=Clouds>Cloud</p></a><a href=/diary/ class="flex items-center"><p class="text-base font-medium text-gray-500 hover:text-gray-900" title=Diaries>Diary</p></a><button id=search-button aria-label=Search class="text-base hover:text-primary-600 dark:hover:text-primary-400 h-12" title>
<span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></button><div class="ltr:mr-14 rtl:ml-14 cursor-pointer text-sm text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400"><button id=appearance-switcher aria-label="Dark mode switcher" type=button><div class="flex items-center justify-center h-12 dark:hidden"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M32 256C32 132.2 132.3 32 255.8 32c11.36.0 29.7 1.668 40.9 3.746 9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3 9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480 132.1 480 32 379.6 32 256z"/></svg></span></div><div class="items-center justify-center hidden h-12 dark:flex"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M256 159.1c-53.02.0-95.1 42.98-95.1 95.1s41.2 96.9 95.1 96.9 95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347l-63.2-91.9 63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89 164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6 12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256 2.74 347.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7 19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109 109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69.0-127.1-57.31-127.1-127.1.0-70.69 57.31-127.1 127.1-127.1S383.1 186.2 383.1 256c0 70.7-56.4 127.1-127.1 127.1z"/></svg></span></div></button></div></nav><div class="flex md:hidden items-center space-x-5 md:ml-12"><span></span>
<button id=search-button-mobile aria-label=Search class="text-base hover:text-primary-600 dark:hover:text-primary-400" title>
<span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></button>
<button id=appearance-switcher-mobile aria-label="Dark mode switcher" type=button style=margin-right:5px><div class="flex items-center justify-center h-12 dark:hidden"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M32 256C32 132.2 132.3 32 255.8 32c11.36.0 29.7 1.668 40.9 3.746 9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3 9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480 132.1 480 32 379.6 32 256z"/></svg></span></div><div class="items-center justify-center hidden h-12 dark:flex"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M256 159.1c-53.02.0-95.1 42.98-95.1 95.1s41.2 96.9 95.1 96.9 95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347l-63.2-91.9 63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89 164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6 12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256 2.74 347.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7 19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109 109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69.0-127.1-57.31-127.1-127.1.0-70.69 57.31-127.1 127.1-127.1S383.1 186.2 383.1 256c0 70.7-56.4 127.1-127.1 127.1z"/></svg></span></div></button></div></div><div class="-my-2 -mr-2 md:hidden"><label id=menu-button for=menu-controller class=block><input type=checkbox id=menu-controller class=hidden><div class="cursor-pointer hover:text-primary-600 dark:hover:text-primary-400"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentcolor" d="M0 96C0 78.33 14.33 64 32 64H416c17.7.0 32 14.33 32 32 0 17.7-14.3 32-32 32H32C14.33 128 0 113.7.0 96zM0 256c0-17.7 14.33-32 32-32H416c17.7.0 32 14.3 32 32s-14.3 32-32 32H32c-17.67.0-32-14.3-32-32zM416 448H32c-17.67.0-32-14.3-32-32s14.33-32 32-32H416c17.7.0 32 14.3 32 32s-14.3 32-32 32z"/></svg></span></div><div id=menu-wrapper style=padding-top:5px class="fixed inset-0 z-30 invisible w-screen h-screen m-0 overflow-auto transition-opacity opacity-0 cursor-default bg-neutral-100/50 backdrop-blur-sm dark:bg-neutral-900/50"><ul class="flex space-y-2 mt-3 flex-col items-end w-full px-6 py-6 mx-auto overflow-visible list-none ltr:text-right rtl:text-left max-w-7xl"><li><span class="cursor-pointer inline-block align-text-bottom hover:text-primary-600 dark:hover:text-primary-400"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path fill="currentcolor" d="M310.6 361.4c12.5 12.5 12.5 32.75.0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3 54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75.0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75.0-45.25s32.75-12.5 45.25.0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25.0s12.5 32.75.0 45.25l-105.4 105.4L310.6 361.4z"/></svg></span></span></li><li class=mt-1><a href=/golang/ class="flex items-center"><p class="text-bg font-bg text-gray-500 hover:text-gray-900" title=Golang>Golang</p></a></li><li class=mt-1><a href=/python/ class="flex items-center"><p class="text-bg font-bg text-gray-500 hover:text-gray-900" title=Pythons>Python</p></a></li><li class=mt-1><a href=/linux/ class="flex items-center"><p class="text-bg font-bg text-gray-500 hover:text-gray-900" title=Linuxes>Linux</p></a></li><li class=mt-1><a href=/basic/ class="flex items-center"><p class="text-bg font-bg text-gray-500 hover:text-gray-900" title=Basics>Basic</p></a></li><li class=mt-1><a href=/cloud/ class="flex items-center"><p class="text-bg font-bg text-gray-500 hover:text-gray-900" title=Clouds>Cloud</p></a></li><li class=mt-1><a href=/diary/ class="flex items-center"><p class="text-bg font-bg text-gray-500 hover:text-gray-900" title=Diaries>Diary</p></a></li></ul></div></label></div></div><script>(function(){var e=$(".main-menu"),t=window.location.pathname;e.find('a[href="'+t+'"]').each(function(e,t){$(t).children("p").addClass("active")})})()</script></div></div><script>window.addEventListener("scroll",function(){var t=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0,n=document.getElementById("menu-blur");n.style.opacity=t/300})</script><div class="relative flex flex-col grow"><main id=main-content class=grow><article><div id=hero class="h-[150px] md:h-[200px]"></div><div class="fixed inset-x-0 top-0 h-[800px] single_hero_background nozoom" style=background-image:url(/basic/redis/review/01/feature_hu12378723d8d648ccbd45d949c7a79f70_7051276_1200x0_resize_q75_box.jpg)><div class="absolute inset-0 bg-gradient-to-t from-neutral dark:from-neutral-800 to-transparent mix-blend-normal"></div><div class="absolute inset-0 opacity-60 bg-gradient-to-t from-neutral dark:from-neutral-800 to-neutral-100 dark:to-neutral-800 mix-blend-normal"></div></div><div id=background-blur class="fixed opacity-0 inset-x-0 top-0 h-full single_hero_background nozoom backdrop-blur-2xl"></div><script>window.addEventListener("scroll",function(){var t=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0,n=document.getElementById("background-blur");n.style.opacity=t/300})</script><header id=single_header class="mt-5 max-w-prose"><ol class="text-sm text-neutral-500 dark:text-neutral-400 print:hidden"><li class="inline hidden"><a class="hover:underline decoration-neutral-300 dark:underline-neutral-600" href=/>Welcome to NewtSun</a><span class="px-1 text-primary-500">/</span></li><li class=inline><a class="hover:underline decoration-neutral-300 dark:underline-neutral-600" href=/basic/>Basics</a><span class="px-1 text-primary-500">/</span></li><li class="inline hidden"><a class="hover:underline decoration-neutral-300 dark:underline-neutral-600" href=/basic/redis/review/01/>Redis 基础</a><span class="px-1 text-primary-500">/</span></li></ol><h1 class="mt-0 text-4xl font-extrabold text-neutral-900 dark:text-neutral">Redis 基础</h1><div class="mt-1 mb-6 text-base text-neutral-500 dark:text-neutral-400 print:hidden"><div class="flex flex-row flex-wrap items-center"><time datetime="2023-09-21 15:29:38 +0800 +0800">21 September 2023</time><span class="px-2 text-primary-500">&#183;</span><span title="Reading time">7 mins</span></div><div class="flex flex-row flex-wrap items-center"><span style=margin-top:.5rem class=mr-2 onclick='window.open("/tags/redis/","_self")'><span class=flex><span class="rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400">Redis</span></span></span>
<span style=margin-top:.5rem class=mr-2 onclick='window.open("/tags/review/","_self")'><span class=flex><span class="rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400">review</span></span></span></div></div><div class=flex><div class=place-self-center><div class="text-2xl sm:text-lg"></div></div></div><div class=mb-5></div></header><section class="flex flex-col max-w-full mt-0 prose dark:prose-invert lg:flex-row"><div class="order-first sm:max-w-prose lg:ml-auto px-0 lg:order-last lg:max-w-xs ltr:lg:pl-8 rtl:lg:pr-8"><div class="toc ltr:pl-5 rtl:pr-5 print:hidden lg:sticky lg:top-[140px]"><details open class="mt-0 overflow-hidden rounded-lg ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 hidden lg:block"><summary class="block py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">Table of Contents</summary><div class="min-w-[220px] py-2 border-dotted border-neutral-300 ltr:-ml-5 ltr:border-l ltr:pl-5 rtl:-mr-5 rtl:border-r rtl:pr-5 dark:border-neutral-600"><nav id=TableOfContents><ul><li><a href=#1基础知识>1.基础知识</a></li><li><a href=#2redis-数据结构>2.Redis 数据结构</a></li><li><a href=#3redis-线程模型>3.Redis 线程模型</a><ul><li><a href=#31-redis-单线程模式>3.1 Redis 单线程模式</a></li><li><a href=#32-redis-性能瓶颈>3.2 Redis 性能瓶颈</a></li><li><a href=#33-redis-60-之后引入多线程>3.3 Redis 6.0 之后引入多线程</a></li></ul></li><li><a href=#4redis-持久化>4.Redis 持久化</a><ul><li><a href=#41-aof-日志>4.1 AOF 日志</a></li><li><a href=#42-rdb-快照>4.2 RDB 快照</a></li><li><a href=#43-混合持久化>4.3 混合持久化</a></li></ul></li><li><a href=#5redis-过期删除与内存淘汰>5.Redis 过期删除与内存淘汰</a><ul><li><a href=#51-redis-的过期删除策略>5.1 Redis 的过期删除策略</a></li><li><a href=#52-redis-持久化时如何处理过期键>5.2 Redis 持久化时，如何处理过期键</a></li><li><a href=#53-redis-主从模式中如何处理过期键>5.3 Redis 主从模式中，如何处理过期键</a></li><li><a href=#54-redis-内存满了会发生什么>5.4 Redis 内存满了，会发生什么</a></li><li><a href=#55-redis-内存淘汰策略>5.5 Redis 内存淘汰策略</a></li><li><a href=#56-lru-算法和-lfu-算法区别>5.6 LRU 算法和 LFU 算法区别</a></li></ul></li><li><a href=#6缓存更新策略>6.缓存更新策略</a><ul><li><a href=#61-cache-aside旁路缓存策略>6.1 Cache Aside（旁路缓存）策略</a></li><li><a href=#62-readwrite-through读穿--写穿策略>6.2 Read/Write Through（读穿 / 写穿）策略</a></li><li><a href=#63-write-back写回策略>6.3 Write Back（写回）策略</a></li></ul></li></ul></nav></div></details><details class="mt-0 overflow-hidden rounded-lg ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 lg:hidden"><summary class="py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">Table of Contents</summary><div class="py-2 border-dotted border-neutral-300 ltr:-ml-5 ltr:border-l ltr:pl-5 rtl:-mr-5 rtl:border-r rtl:pr-5 dark:border-neutral-600"><nav id=TableOfContents><ul><li><a href=#1基础知识>1.基础知识</a></li><li><a href=#2redis-数据结构>2.Redis 数据结构</a></li><li><a href=#3redis-线程模型>3.Redis 线程模型</a><ul><li><a href=#31-redis-单线程模式>3.1 Redis 单线程模式</a></li><li><a href=#32-redis-性能瓶颈>3.2 Redis 性能瓶颈</a></li><li><a href=#33-redis-60-之后引入多线程>3.3 Redis 6.0 之后引入多线程</a></li></ul></li><li><a href=#4redis-持久化>4.Redis 持久化</a><ul><li><a href=#41-aof-日志>4.1 AOF 日志</a></li><li><a href=#42-rdb-快照>4.2 RDB 快照</a></li><li><a href=#43-混合持久化>4.3 混合持久化</a></li></ul></li><li><a href=#5redis-过期删除与内存淘汰>5.Redis 过期删除与内存淘汰</a><ul><li><a href=#51-redis-的过期删除策略>5.1 Redis 的过期删除策略</a></li><li><a href=#52-redis-持久化时如何处理过期键>5.2 Redis 持久化时，如何处理过期键</a></li><li><a href=#53-redis-主从模式中如何处理过期键>5.3 Redis 主从模式中，如何处理过期键</a></li><li><a href=#54-redis-内存满了会发生什么>5.4 Redis 内存满了，会发生什么</a></li><li><a href=#55-redis-内存淘汰策略>5.5 Redis 内存淘汰策略</a></li><li><a href=#56-lru-算法和-lfu-算法区别>5.6 LRU 算法和 LFU 算法区别</a></li></ul></li><li><a href=#6缓存更新策略>6.缓存更新策略</a><ul><li><a href=#61-cache-aside旁路缓存策略>6.1 Cache Aside（旁路缓存）策略</a></li><li><a href=#62-readwrite-through读穿--写穿策略>6.2 Read/Write Through（读穿 / 写穿）策略</a></li><li><a href=#63-write-back写回策略>6.3 Write Back（写回）策略</a></li></ul></li></ul></nav></div></details><script>(function(){var t,e=$("#TableOfContents");if(e.length>0){t=$(window);function n(){var s,o=t.scrollTop(),i=$(".anchor"),n="";if(i.each(function(e,t){t=$(t),t.offset().top-$(window).height()/3<=o&&(n=t.attr("id"))}),s=e.find("a.active"),s.length==1&&s.eq(0).attr("href")=="#"+n)return!0;s.each(function(e,t){$(t).removeClass("active")}),e.find('a[href="#'+n+'"]').addClass("active"),e.find('a[href="#'+n+'"]').parentsUntil("#TableOfContents").each(function(e,t){$(t).children("a").parents("ul").show()})}t.on("scroll",n),$(document).ready(function(){n()})}})()</script></div></div><div class="min-w-0 min-h-0 max-w-fit"><div class="max-w-prose mb-20"><p>Redis 相关知识复习</p><div id=1基础知识 class=anchor></div><h2 class="relative group">1.基础知识
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#1%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86 aria-label=Anchor>#</a></span></h2><p>Redis：基于内存的数据库，数据的读写操作都是在内存中，常用于缓存、消息队列、分布式锁</p><p>Redis 对数据类型的操作都是<strong>原子性</strong>的（因为执行命令由单线程负责，不存在并发竞争问题）</p><p>Redis 可以作为 MySQL 的缓存，因为 Redis 具备高性能和高并发两种特性</p><div id=2redis-数据结构 class=anchor></div><h2 class="relative group">2.Redis 数据结构
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#2redis-%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 aria-label=Anchor>#</a></span></h2><p>Redis 提供了丰富的数据类型，常见的有五种数据类型：<strong>String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）</strong></p><p><figure><img class="my-0 rounded-md" srcset="/basic/redis/review/01/img/image-20230921111251423_hu5ec09cc9595c377c83b38b8926d8b9b4_102379_330x0_resize_box_3.png 330w,
/basic/redis/review/01/img/image-20230921111251423_hu5ec09cc9595c377c83b38b8926d8b9b4_102379_660x0_resize_box_3.png 660w,
/basic/redis/review/01/img/image-20230921111251423_hu5ec09cc9595c377c83b38b8926d8b9b4_102379_1024x0_resize_box_3.png 1024w,
/basic/redis/review/01/img/image-20230921111251423_hu5ec09cc9595c377c83b38b8926d8b9b4_102379_1320x0_resize_box_3.png 2x" src=/basic/redis/review/01/img/image-20230921111251423_hu5ec09cc9595c377c83b38b8926d8b9b4_102379_660x0_resize_box_3.png alt></figure></p><p><figure><img class="my-0 rounded-md" srcset="/basic/redis/review/01/img/image-20230921111254802_hu5c582aca3da8e477a719c2a481628fde_450830_330x0_resize_box_3.png 330w,
/basic/redis/review/01/img/image-20230921111254802_hu5c582aca3da8e477a719c2a481628fde_450830_660x0_resize_box_3.png 660w,
/basic/redis/review/01/img/image-20230921111254802_hu5c582aca3da8e477a719c2a481628fde_450830_1024x0_resize_box_3.png 1024w,
/basic/redis/review/01/img/image-20230921111254802_hu5c582aca3da8e477a719c2a481628fde_450830_1320x0_resize_box_3.png 2x" src=/basic/redis/review/01/img/image-20230921111254802_hu5c582aca3da8e477a719c2a481628fde_450830_660x0_resize_box_3.png alt></figure></p><p>随着 Redis 版本的更新，后面又支持了四种数据类型： <strong>BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增）</strong>。 Redis 五种数据类型的应用场景：</p><ul><li>String 类型的应用场景：缓存对象、常规计数、分布式锁、共享 session 信息等。</li><li>List 类型的应用场景：消息队列（但是有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据）等。</li><li>Hash 类型：缓存对象、购物车等。</li><li>Set 类型：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。</li><li>Zset 类型：排序场景，比如排行榜、电话和姓名排序等。</li></ul><p>Redis 后续版本又支持四种数据类型，它们的应用场景如下：</p><ul><li>BitMap（2.2 版新增）：二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等；</li><li>HyperLogLog（2.8 版新增）：海量数据基数统计的场景，比如百万级网页 UV 计数等；</li><li>GEO（3.2 版新增）：存储地理位置信息的场景，比如滴滴叫车；</li><li>Stream（5.0 版新增）：消息队列，相比于基于 List 类型实现的消息队列，有这两个特有的特性：自动生成全局唯一消息ID，支持以消费组形式消费数据。</li></ul><p><figure><img class="my-0 rounded-md" srcset="/basic/redis/review/01/img/image-20230921111317288_hub41b3b0fc783bc48394ec11549ea1df9_267723_330x0_resize_box_3.png 330w,
/basic/redis/review/01/img/image-20230921111317288_hub41b3b0fc783bc48394ec11549ea1df9_267723_660x0_resize_box_3.png 660w,
/basic/redis/review/01/img/image-20230921111317288_hub41b3b0fc783bc48394ec11549ea1df9_267723_1024x0_resize_box_3.png 1024w,
/basic/redis/review/01/img/image-20230921111317288_hub41b3b0fc783bc48394ec11549ea1df9_267723_1320x0_resize_box_3.png 2x" src=/basic/redis/review/01/img/image-20230921111317288_hub41b3b0fc783bc48394ec11549ea1df9_267723_660x0_resize_box_3.png alt></figure></p><div id=3redis-线程模型 class=anchor></div><h2 class="relative group">3.Redis 线程模型
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#3redis-%e7%ba%bf%e7%a8%8b%e6%a8%a1%e5%9e%8b aria-label=Anchor>#</a></span></h2><p><strong>Redis 单线程指的是「接收客户端请求->解析请求 ->进行数据读写等操作->发送数据给客户端」这个过程是由一个线程（主线程）来完成的</strong>，这也是我们常说 Redis 是单线程的原因。</p><p>但是，<strong>Redis 程序并不是单线程的</strong>，Redis 在启动的时候，是会<strong>启动后台线程</strong>（BIO）的：</p><ul><li><strong>Redis 在 2.6 版本</strong>，会启动 2 个后台线程，分别处理关闭文件、AOF 刷盘这两个任务；</li><li><strong>Redis 在 4.0 版本之后</strong>，新增了一个新的后台线程，用来异步释放 Redis 内存，也就是 lazyfree 线程。例如执行 unlink key / flushdb async / flushall async 等命令，会把这些删除操作交给后台线程来执行，好处是不会导致 Redis 主线程卡顿。因此，当我们要删除一个大 key 的时候，不要使用 del 命令删除，因为 del 是在主线程处理的，这样会导致 Redis 主线程卡顿，因此我们应该使用 unlink 命令来异步删除大key。</li></ul><p>之所以 Redis 为「关闭文件、AOF 刷盘、释放内存」这些任务创建单独的线程来处理，是因为这些任务的操作都是很耗时的，如果把这些任务都放在主线程来处理，那么 Redis 主线程就很容易发生阻塞，这样就无法处理后续的请求了。</p><p>后台线程相当于一个消费者，生产者把耗时任务丢到任务队列中，消费者（BIO）不停轮询这个队列，拿出任务就去执行对应的方法即可。</p><p><figure><img class="my-0 rounded-md" srcset="/basic/redis/review/01/img/image-20230921114220869_hucc631e9f0506f7778e870d0f4987160b_293120_330x0_resize_box_3.png 330w,
/basic/redis/review/01/img/image-20230921114220869_hucc631e9f0506f7778e870d0f4987160b_293120_660x0_resize_box_3.png 660w,
/basic/redis/review/01/img/image-20230921114220869_hucc631e9f0506f7778e870d0f4987160b_293120_1024x0_resize_box_3.png 1024w,
/basic/redis/review/01/img/image-20230921114220869_hucc631e9f0506f7778e870d0f4987160b_293120_1320x0_resize_box_3.png 2x" src=/basic/redis/review/01/img/image-20230921114220869_hucc631e9f0506f7778e870d0f4987160b_293120_660x0_resize_box_3.png alt></figure></p><p>关闭文件、AOF 刷盘、释放内存这三个任务都有各自的任务队列：</p><ul><li>BIO_CLOSE_FILE，关闭文件任务队列：当队列有任务后，后台线程会调用 close(fd) ，将文件关闭；</li><li>BIO_AOF_FSYNC，AOF刷盘任务队列：当 AOF 日志配置成 everysec 选项后，主线程会把 AOF 写日志操作封装成一个任务，也放到队列中。当发现队列有任务后，后台线程会调用 fsync(fd)，将 AOF 文件刷盘，</li><li>BIO_LAZY_FREE，lazy free 任务队列：当队列有任务后，后台线程会 free(obj) 释放对象 / free(dict) 删除数据库所有对象 / free(skiplist) 释放跳表对象；</li></ul><div id=31-redis-单线程模式 class=anchor></div><h3 class="relative group">3.1 Redis 单线程模式
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#31-redis-%e5%8d%95%e7%ba%bf%e7%a8%8b%e6%a8%a1%e5%bc%8f aria-label=Anchor>#</a></span></h3><p><figure><img class="my-0 rounded-md" srcset="/basic/redis/review/01/img/image-20230921114948266_hu9f58bd09476daeced433e3923f168e47_929937_330x0_resize_box_3.png 330w,
/basic/redis/review/01/img/image-20230921114948266_hu9f58bd09476daeced433e3923f168e47_929937_660x0_resize_box_3.png 660w,
/basic/redis/review/01/img/image-20230921114948266_hu9f58bd09476daeced433e3923f168e47_929937_1024x0_resize_box_3.png 1024w,
/basic/redis/review/01/img/image-20230921114948266_hu9f58bd09476daeced433e3923f168e47_929937_1320x0_resize_box_3.png 2x" src=/basic/redis/review/01/img/image-20230921114948266_hu9f58bd09476daeced433e3923f168e47_929937_660x0_resize_box_3.png alt></figure></p><p>图中的蓝色部分是一个事件循环，是由主线程负责的，可以看到网络 I/O 和命令处理都是单线程。 Redis 初始化的时候，会做下面这几件事情：</p><ul><li>首先，调用 epoll_create() 创建一个 epoll 对象和调用 socket() 创建一个服务端 socket</li><li>然后，调用 bind() 绑定端口和调用 listen() 监听该 socket；</li><li>然后，将调用 epoll_ctl() 将 listen socket 加入到 epoll，同时注册「连接事件」处理函数。</li></ul><p>初始化完后，主线程就进入到一个<strong>事件循环函数</strong>，主要会做以下事情：</p><ul><li>首先，先调用<strong>处理发送队列函数</strong>，看是发送队列里是否有任务，如果有发送任务，则通过 write 函数将客户端发送缓存区里的数据发送出去，如果这一轮数据没有发送完，就会注册写事件处理函数，等待 epoll_wait 发现可写后再处理 。</li><li>接着，调用 epoll_wait 函数等待事件的到来：<ul><li>如果是<strong>连接事件</strong>到来，则会调用<strong>连接事件处理函数</strong>，该函数会做这些事情：调用 accpet 获取已连接的 socket -> 调用 epoll_ctl 将已连接的 socket 加入到 epoll -> 注册「读事件」处理函数；</li><li>如果是<strong>读事件</strong>到来，则会调用<strong>读事件处理函数</strong>，该函数会做这些事情：调用 read 获取客户端发送的数据 -> 解析命令 -> 处理命令 -> 将客户端对象添加到发送队列 -> 将执行结果写到发送缓存区等待发送；</li><li>如果是<strong>写事件</strong>到来，则会调用<strong>写事件处理函数</strong>，该函数会做这些事情：通过 write 函数将客户端发送缓存区里的数据发送出去，如果这一轮数据没有发送完，就会继续注册写事件处理函数，等待 epoll_wait 发现可写后再处理 。</li></ul></li></ul><p>Redis 采用单线程（网络 I/O 和执行命令）那么快，有如下几个原因：</p><ul><li>Redis 的大部分操作<strong>都在内存中完成</strong>，并且采用了高效的数据结构，因此 Redis 瓶颈可能是机器的内存或者网络带宽，而并非 CPU，既然 CPU 不是瓶颈，那么自然就采用单线程的解决方案了；</li><li>Redis 采用单线程模型可以<strong>避免了多线程之间的竞争</strong>，省去了多线程切换带来的时间和性能上的开销，而且也不会导致死锁问题。</li><li>Redis 采用了 <strong>I/O 多路复用机制</strong>处理大量的客户端 Socket 请求，IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听 Socket 和已连接 Socket。内核会一直监听这些 Socket 上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。</li></ul><div id=32-redis-性能瓶颈 class=anchor></div><h3 class="relative group">3.2 Redis 性能瓶颈
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#32-redis-%e6%80%a7%e8%83%bd%e7%93%b6%e9%a2%88 aria-label=Anchor>#</a></span></h3><p>Redis的<strong>性能瓶颈有时会出现在网络I/O的处理</strong>上，这是因为Redis是一个内存数据库，它的性能主要受限于以下几个因素：</p><ol><li><strong>单线程模型：</strong> Redis 采用了单线程模型，意味着所有的命令都在一个单独的线程中执行。这个线程负责处理所有的客户端请求、命令解析、数据读写和持久化操作。虽然这样的设计简单且易于维护，但在高并发的情况下，单线程的性能可能会受限。</li><li><strong>内存访问：</strong> Redis 的数据通常存储在内存中，因此快速的内存访问对性能至关重要。然而，当数据量很大时，内存访问可能会变得相对较慢，因为需要更多的内存管理和缓存机制来处理大量的数据。</li><li><strong>网络 I/O：</strong> Redis 通常用于客户端和服务器之间的通信，因此网络I/O的性能对于Redis非常关键。在高并发情况下，大量的客户端请求需要在网络上传输，而网络带宽和延迟可能会成为性能瓶颈。</li><li><strong>持久化操作：</strong> 如果 Redis 启用了持久化操作（如 RDB 快照或 AOF 日志），这些操作可能会对性能产生影响。在持久化期间，Redis需要将数据写入磁盘，这可能会导致磁盘 I/O 成为性能瓶颈。</li></ol><p>解决Redis性能瓶颈的方法包括：</p><ul><li><strong>使用多实例：</strong> 在多核 CPU 上运行多个 Redis 实例，每个实例可以处理不同的命令或数据集，以提高并发性能。</li><li><strong>使用缓存：</strong> 将热点数据缓存在 Redis 中，以减少对数据库的访问。</li><li><strong>使用集群：</strong> Redis 提供了集群模式，可以在多个 Redis 节点之间分布数据和负载，以提高性能和可伸缩性。</li><li><strong>优化网络配置：</strong> 调整网络配置，包括 TCP 参数、最大连接数和超时设置，以改善网络 I/O 性能.</li><li><strong>合理使用持久化：</strong> 根据需求合理配置持久化操作，可以选择关闭持久化或将持久化数据存储在快速的存储介质上。</li></ul><div id=33-redis-60-之后引入多线程 class=anchor></div><h3 class="relative group">3.3 Redis 6.0 之后引入多线程
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#33-redis-60-%e4%b9%8b%e5%90%8e%e5%bc%95%e5%85%a5%e5%a4%9a%e7%ba%bf%e7%a8%8b aria-label=Anchor>#</a></span></h3><p>虽然 Redis 的主要工作（网络 I/O 和执行命令）一直是单线程模型，但是<strong>在 Redis 6.0 版本之后，也采用了多个 I/O 线程来处理网络请求</strong>，<strong>这是因为随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在网络 I/O 的处理上</strong>。</p><p>所以为了提高网络 I/O 的并行度，Redis 6.0 对于网络 I/O 采用多线程来处理。<strong>但是对于命令的执行，Redis 仍然使用单线程来处理，<strong>所以大家</strong>不要误解</strong> Redis 有多线程同时执行命令。</p><p>Redis 官方表示，<strong>Redis 6.0 版本引入的多线程 I/O 特性对性能提升至少是一倍以上</strong>。</p><p>Redis 6.0 版本支持的 I/O 多线程特性，默认情况下 I/O 多线程只针对发送响应数据（write client socket），并不会以多线程的方式处理读请求（read client socket）。要想开启多线程处理客户端读请求，就需要把 Redis.conf 配置文件中的 io-threads-do-reads 配置项设为 yes。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>//读请求也使用io多线程
</span></span><span class=line><span class=cl>io-threads-do-reads yes 
</span></span></code></pre></div><p>同时， Redis.conf 配置文件中提供了 IO 多线程个数的配置项。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>// io-threads N，表示启用 N-1 个 I/O 多线程（主线程也算一个 I/O 线程）
</span></span><span class=line><span class=cl>io-threads <span class=m>4</span> 
</span></span></code></pre></div><p>关于线程数的设置，官方的建议是如果为 4 核的 CPU，建议线程数设置为 2 或 3，如果为 8 核 CPU 建议线程数设置为 6，线程数一定要小于机器核数，线程数并不是越大越好。</p><p>因此， Redis 6.0 版本之后，Redis 在启动的时候，默认情况下会<strong>额外创建 6 个线程</strong>（<em>这里的线程数不包括主线程</em>）：</p><ul><li>Redis-server ： Redis的主线程，主要负责执行命令；</li><li>bio_close_file、bio_aof_fsync、bio_lazy_free：三个后台线程，分别异步处理关闭文件任务、AOF刷盘任务、释放内存任务；</li><li>io_thd_1、io_thd_2、io_thd_3：三个 I/O 线程，io-threads 默认是 4 ，所以会启动 3（4-1）个 I/O 多线程，用来分担 Redis 网络 I/O 的压力。</li></ul><div id=4redis-持久化 class=anchor></div><h2 class="relative group">4.Redis 持久化
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#4redis-%e6%8c%81%e4%b9%85%e5%8c%96 aria-label=Anchor>#</a></span></h2><p>Redis 的读写操作都是在内存中，所以 Redis 性能才会高，但是当 Redis 重启后，内存中的数据就会丢失，那为了保证内存中的数据不会丢失，Redis 实现了数据持久化的机制，这个机制会把数据存储到磁盘，这样在 Redis 重启就能够从磁盘中恢复原有的数据。</p><p>Redis 共有三种数据持久化的方式：</p><ul><li><strong>AOF 日志</strong>：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里；</li><li><strong>RDB 快照</strong>：将某一时刻的内存数据，以二进制的方式写入磁盘；</li><li><strong>混合持久化方式</strong>：Redis 4.0 新增的方式，集成了 AOF 和 RDB 的优点；</li></ul><div id=41-aof-日志 class=anchor></div><h3 class="relative group">4.1 AOF 日志
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#41-aof-%e6%97%a5%e5%bf%97 aria-label=Anchor>#</a></span></h3><p>Redis 在执行完一条写操作命令后，就会把该命令以追加的方式写入到一个文件里，然后 Redis 重启时，会读取该文件记录的命令，然后逐一执行命令的方式来进行数据恢复。</p><p><figure><img class="my-0 rounded-md" srcset="/basic/redis/review/01/img/image-20230921130815636_huc53dd3d3671bcf860ac62d564f12a031_71356_330x0_resize_box_3.png 330w,
/basic/redis/review/01/img/image-20230921130815636_huc53dd3d3671bcf860ac62d564f12a031_71356_660x0_resize_box_3.png 660w,
/basic/redis/review/01/img/image-20230921130815636_huc53dd3d3671bcf860ac62d564f12a031_71356_1024x0_resize_box_3.png 1024w,
/basic/redis/review/01/img/image-20230921130815636_huc53dd3d3671bcf860ac62d564f12a031_71356_1320x0_resize_box_3.png 2x" src=/basic/redis/review/01/img/image-20230921130815636_huc53dd3d3671bcf860ac62d564f12a031_71356_660x0_resize_box_3.png alt></figure></p><p>我这里以「<em>set name xiaolin</em>」命令作为例子，Redis 执行了这条命令后，记录在 AOF 日志里的内容如下图：</p><p><figure><img class="my-0 rounded-md" srcset="/basic/redis/review/01/img/image-20230921130820745_hud212aa006c877d6490a96a59d4b38d4f_69172_330x0_resize_box_3.png 330w,
/basic/redis/review/01/img/image-20230921130820745_hud212aa006c877d6490a96a59d4b38d4f_69172_660x0_resize_box_3.png 660w,
/basic/redis/review/01/img/image-20230921130820745_hud212aa006c877d6490a96a59d4b38d4f_69172_1024x0_resize_box_3.png 1024w,
/basic/redis/review/01/img/image-20230921130820745_hud212aa006c877d6490a96a59d4b38d4f_69172_1320x0_resize_box_3.png 2x" src=/basic/redis/review/01/img/image-20230921130820745_hud212aa006c877d6490a96a59d4b38d4f_69172_660x0_resize_box_3.png alt></figure></p><blockquote><p>为什么先执行命令，再把数据写入日志呢？</p></blockquote><p>Reids 是先执行写操作命令后，才将该命令记录到 AOF 日志里的，这么做其实有两个好处。</p><ul><li><strong>避免额外的检查开销</strong>：因为如果先将写操作命令记录到 AOF 日志里，再执行该命令的话，如果当前的命令语法有问题，那么如果不进行命令语法检查，该错误的命令记录到 AOF 日志里后，Redis 在使用日志恢复数据时，就可能会出错。</li><li><strong>不会阻塞当前写操作命令的执行</strong>：因为当写操作命令执行成功后，才会将命令记录到 AOF 日志。</li></ul><p>当然，这样做也会带来风险：</p><ul><li><strong>数据可能会丢失：</strong> 执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个数据就会有丢失的风险。</li><li><strong>可能阻塞其他操作：</strong> 由于写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前命令的执行，但因为 AOF 日志也是在主线程中执行，所以当 Redis 把日志文件写入磁盘的时候，还是会阻塞后续的操作无法执行。</li></ul><blockquote><p>AOF 写回策略有几种？</p></blockquote><p>Redis 写入 AOF 日志的过程，如下图：</p><p><figure><img class="my-0 rounded-md" srcset="/basic/redis/review/01/img/image-20230921134103459_huf2b4bc1f76cc381fca3e6de05619b0fa_141181_330x0_resize_box_3.png 330w,
/basic/redis/review/01/img/image-20230921134103459_huf2b4bc1f76cc381fca3e6de05619b0fa_141181_660x0_resize_box_3.png 660w,
/basic/redis/review/01/img/image-20230921134103459_huf2b4bc1f76cc381fca3e6de05619b0fa_141181_1024x0_resize_box_3.png 1024w,
/basic/redis/review/01/img/image-20230921134103459_huf2b4bc1f76cc381fca3e6de05619b0fa_141181_1320x0_resize_box_3.png 2x" src=/basic/redis/review/01/img/image-20230921134103459_huf2b4bc1f76cc381fca3e6de05619b0fa_141181_660x0_resize_box_3.png alt></figure></p><p>具体说说：</p><ol><li>Redis 执行完写操作命令后，会将命令追加到 server.aof_buf 缓冲区；</li><li>然后通过 write() 系统调用，将 aof_buf 缓冲区的数据写入到 AOF 文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 page cache，等待内核将数据写入硬盘；</li><li>具体内核缓冲区的数据什么时候写入到硬盘，由内核决定。</li></ol><p>Redis 提供了 3 种写回硬盘的策略，控制的就是上面说的第三步的过程。 在 Redis.conf 配置文件中的 appendfsync 配置项可以有以下 3 种参数可填：</p><ul><li><strong>Always</strong>，这个单词的意思是「总是」，所以它的意思是每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘；</li><li><strong>Everysec</strong>，这个单词的意思是「每秒」，所以它的意思是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘；</li><li><strong>No</strong>，意味着不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。</li></ul><p><figure><img class="my-0 rounded-md" srcset="/basic/redis/review/01/img/image-20230921134056702_hu0759873b5f4c5668867f9d0b0ca2f234_156195_330x0_resize_box_3.png 330w,
/basic/redis/review/01/img/image-20230921134056702_hu0759873b5f4c5668867f9d0b0ca2f234_156195_660x0_resize_box_3.png 660w,
/basic/redis/review/01/img/image-20230921134056702_hu0759873b5f4c5668867f9d0b0ca2f234_156195_1024x0_resize_box_3.png 1024w,
/basic/redis/review/01/img/image-20230921134056702_hu0759873b5f4c5668867f9d0b0ca2f234_156195_1320x0_resize_box_3.png 2x" src=/basic/redis/review/01/img/image-20230921134056702_hu0759873b5f4c5668867f9d0b0ca2f234_156195_660x0_resize_box_3.png alt></figure></p><blockquote><p>AOF 日志过大，会触发什么机制？</p></blockquote><p>AOF 日志是一个文件，随着执行的写操作命令越来越多，文件的大小会越来越大。 如果当 AOF 日志文件过大就会带来性能问题，比如重启 Redis 后，需要读 AOF 文件的内容以恢复数据，如果文件过大，整个恢复的过程就会很慢。</p><p>所以，Redis 为了避免 AOF 文件越写越大，提供了 <strong>AOF 重写机制</strong>，当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件。</p><p>AOF 重写机制是在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件。</p><p>举个例子，在没有使用重写机制前，假设前后执行了「<em>set name xiaolin</em>」和「<em>set name xiaolincoding</em>」这两个命令的话，就会将这两个命令记录到 AOF 文件。</p><p><figure><img class="my-0 rounded-md" srcset="/basic/redis/review/01/img/image-20230921134118961_hu3fd5f820bb176c85e2aafd2c21f9a521_185550_330x0_resize_box_3.png 330w,
/basic/redis/review/01/img/image-20230921134118961_hu3fd5f820bb176c85e2aafd2c21f9a521_185550_660x0_resize_box_3.png 660w,
/basic/redis/review/01/img/image-20230921134118961_hu3fd5f820bb176c85e2aafd2c21f9a521_185550_1024x0_resize_box_3.png 1024w,
/basic/redis/review/01/img/image-20230921134118961_hu3fd5f820bb176c85e2aafd2c21f9a521_185550_1320x0_resize_box_3.png 2x" src=/basic/redis/review/01/img/image-20230921134118961_hu3fd5f820bb176c85e2aafd2c21f9a521_185550_660x0_resize_box_3.png alt></figure></p><p>但是<strong>在使用重写机制后，就会读取 name 最新的 value（键值对） ，然后用一条 「set name xiaolincoding」命令记录到新的 AOF 文件</strong>，之前的第一个命令就没有必要记录了，因为它属于「历史」命令，没有作用了。这样一来，一个键值对在重写日志中只用一条命令就行了。</p><p>重写工作完成后，就会将新的 AOF 文件覆盖现有的 AOF 文件，这就相当于压缩了 AOF 文件，使得 AOF 文件体积变小了。</p><blockquote><p>重写 AOF 日志的过程是怎样的？</p></blockquote><p>Redis 的<strong>重写 AOF 过程是由后台子进程 <em>bgrewriteaof</em> 来完成的</strong>，这么做可以达到两个好处：</p><ul><li>子进程进行 AOF 重写期间，主进程可以继续处理命令请求，从而避免阻塞主进程；</li><li>子进程带有主进程的数据副本，这里使用子进程而不是线程，因为如果是使用线程，多线程之间会共享内存，那么在修改共享内存数据的时候，需要通过加锁来保证数据的安全，而这样就会降低性能。而使用子进程，创建子进程时，父子进程是共享内存数据的，不过这个共享的内存只能以只读的方式，而当父子进程任意一方修改了该共享内存，就会发生「写时复制」，于是父子进程就有了独立的数据副本，就不用加锁来保证数据安全。</li></ul><p>触发重写机制后，主进程就会创建重写 AOF 的子进程，此时父子进程共享物理内存，重写子进程只会对这个内存进行只读，重写 AOF 子进程会读取数据库里的所有数据，并逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志（新的 AOF 文件）。</p><p><strong>但是重写过程中，主进程依然可以正常处理命令</strong>，那问题来了，重写 AOF 日志过程中，如果主进程修改了已经存在 key-value，那么会发生写时复制，此时这个 key-value 数据在子进程的内存数据就跟主进程的内存数据不一致了，这时要怎么办呢？</p><p>为了解决这种数据不一致问题，Redis 设置了一个 <strong>AOF 重写缓冲区</strong>，这个缓冲区在创建 bgrewriteaof 子进程之后开始使用。</p><p>在重写 AOF 期间，当 Redis 执行完一个写命令之后，它会<strong>同时将这个写命令写入到 「AOF 缓冲区」和 「AOF 重写缓冲区」</strong>。</p><p><figure><img class="my-0 rounded-md" srcset="/basic/redis/review/01/img/image-20230921134131141_hude2b0e8a72e6b0c58940be90488254c7_270910_330x0_resize_box_3.png 330w,
/basic/redis/review/01/img/image-20230921134131141_hude2b0e8a72e6b0c58940be90488254c7_270910_660x0_resize_box_3.png 660w,
/basic/redis/review/01/img/image-20230921134131141_hude2b0e8a72e6b0c58940be90488254c7_270910_1024x0_resize_box_3.png 1024w,
/basic/redis/review/01/img/image-20230921134131141_hude2b0e8a72e6b0c58940be90488254c7_270910_1320x0_resize_box_3.png 2x" src=/basic/redis/review/01/img/image-20230921134131141_hude2b0e8a72e6b0c58940be90488254c7_270910_660x0_resize_box_3.png alt></figure></p><p>也就是说，在 bgrewriteaof 子进程执行 AOF 重写期间，主进程需要执行以下三个工作:</p><ul><li>执行客户端发来的命令；</li><li>将执行后的写命令追加到 「AOF 缓冲区」；</li><li>将执行后的写命令追加到 「AOF 重写缓冲区」；</li></ul><p>当子进程完成 AOF 重写工作（<em>扫描数据库中所有数据，逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志</em>）后，会向主进程发送一条信号，信号是进程间通讯的一种方式，且是异步的。</p><p>主进程收到该信号后，会调用一个信号处理函数，该函数主要做以下工作：</p><ul><li>将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中，使得新旧两个 AOF 文件所保存的数据库状态一致；</li><li>新的 AOF 的文件进行改名，覆盖现有的 AOF 文件。</li></ul><p>信号函数执行完后，主进程就可以继续像往常一样处理命令了。</p><blockquote><p>Redis 的 AOF 是在主线程进行的还是子线程？</p></blockquote><p>Redis 的 AOF（Append-Only File）持久化操作是在主线程中进行的，而不是在子线程中。</p><p>Redis 的主要线程负责处理所有的客户端请求、命令执行、数据读写、AOF 日志的更新等任务。当有命令需要被持久化到 AOF 文件时，Redis 主线程会将该命令追加到 AOF 缓冲区中，然后异步地将 AOF 缓冲区中的内容写入 AOF 文件。这个写入操作通常在后台执行，不会阻塞主线程的正常工作。</p><p>由于 AOF 持久化是以追加方式进行的，它不会直接修改已有的 AOF 文件，而是在文件末尾追加新的命令。这意味着即使 AOF 写入操作失败或中断，也不会影响到原有的 AOF 文件的完整性，因此 AOF 持久化具有一定的容错性。</p><p>总之，Redis 的 AOF 持久化是在主线程中进行的，但不会阻塞主线程的正常处理能力，因为 AOF 写入操作通常是异步的。</p><div id=42-rdb-快照 class=anchor></div><h3 class="relative group">4.2 RDB 快照
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#42-rdb-%e5%bf%ab%e7%85%a7 aria-label=Anchor>#</a></span></h3><p>因为 AOF 日志记录的是操作命令，不是实际的数据，所以用 AOF 方法做故障恢复时，需要全量把日志都执行一遍，一旦 AOF 日志非常多，势必会造成 Redis 的恢复操作缓慢。</p><p>为了解决这个问题，Redis 增加了 RDB 快照。所谓的快照，就是记录某一个瞬间东西，比如当我们给风景拍照时，那一个瞬间的画面和信息就记录到了一张照片。</p><p>所以，RDB 快照就是记录某一个瞬间的内存数据，记录的是实际数据，而 AOF 文件记录的是命令操作的日志，而不是实际的数据。</p><p>因此在 Redis 恢复数据时， RDB 恢复数据的效率会比 AOF 高些，因为直接将 RDB 文件读入内存就可以，不需要像 AOF 那样还需要额外执行操作命令的步骤才能恢复数据。</p><blockquote><p>RDB 做快照时会阻塞线程吗？</p></blockquote><p>Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave，他们的区别就在于是否在「主线程」里执行：</p><ul><li>执行了 save 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，<strong>会阻塞主线程</strong>；</li><li>执行了 bgsave 命令，会创建一个子进程来生成 RDB 文件，这样可以<strong>避免主线程的阻塞</strong>；</li></ul><p>Redis 还可以通过配置文件的选项来实现每隔一段时间自动执行一次 bgsave 命令，默认会提供以下配置：</p><pre tabindex=0><code>save 900 1
save 300 10
save 60 10000
</code></pre><p>别看选项名叫 save，实际上执行的是 bgsave 命令，也就是会创建子进程来生成 RDB 快照文件。 只要满足上面条件的任意一个，就会执行 bgsave，它们的意思分别是：</p><ul><li>900 秒之内，对数据库进行了至少 1 次修改；</li><li>300 秒之内，对数据库进行了至少 10 次修改；</li><li>60 秒之内，对数据库进行了至少 10000 次修改。</li></ul><p>这里提一点，Redis 的快照是<strong>全量快照</strong>，也就是说每次执行快照，都是把内存中的「所有数据」都记录到磁盘中。所以执行快照是一个比较重的操作，如果频率太频繁，可能会对 Redis 性能产生影响。如果频率太低，服务器故障时，丢失的数据会更多。</p><blockquote><p>RDB 在执行快照的时候，数据能修改吗？</p></blockquote><p>可以的，执行 bgsave 过程中，Redis 依然<strong>可以继续处理操作命令</strong>的，也就是数据是能被修改的，关键的技术就在于<strong>写时复制技术（Copy-On-Write, COW）。</strong></p><p>执行 bgsave 命令的时候，会通过 fork() 创建子进程，此时子进程和父进程是共享同一片内存数据的，因为创建子进程的时候，会复制父进程的页表，但是页表指向的物理内存还是一个，此时如果主线程执行读操作，则主线程和 bgsave 子进程互相不影响。</p><p><figure><img class="my-0 rounded-md" srcset="/basic/redis/review/01/img/image-20230921134231217_hud5c536034d46b32bcb12cdcaaed86f67_80295_330x0_resize_box_3.png 330w,
/basic/redis/review/01/img/image-20230921134231217_hud5c536034d46b32bcb12cdcaaed86f67_80295_660x0_resize_box_3.png 660w,
/basic/redis/review/01/img/image-20230921134231217_hud5c536034d46b32bcb12cdcaaed86f67_80295_1024x0_resize_box_3.png 1024w,
/basic/redis/review/01/img/image-20230921134231217_hud5c536034d46b32bcb12cdcaaed86f67_80295_1320x0_resize_box_3.png 2x" src=/basic/redis/review/01/img/image-20230921134231217_hud5c536034d46b32bcb12cdcaaed86f67_80295_660x0_resize_box_3.png alt></figure></p><p>如果主线程执行写操作，则被修改的数据会复制一份副本，然后 bgsave 子进程会把该副本数据写入 RDB 文件，在这个过程中，主线程仍然可以直接修改原来的数据。</p><p><figure><img class="my-0 rounded-md" srcset="/basic/redis/review/01/img/image-20230921134241331_hu031c61dc5645769e387a67ea59594a16_92180_330x0_resize_box_3.png 330w,
/basic/redis/review/01/img/image-20230921134241331_hu031c61dc5645769e387a67ea59594a16_92180_660x0_resize_box_3.png 660w,
/basic/redis/review/01/img/image-20230921134241331_hu031c61dc5645769e387a67ea59594a16_92180_1024x0_resize_box_3.png 1024w,
/basic/redis/review/01/img/image-20230921134241331_hu031c61dc5645769e387a67ea59594a16_92180_1320x0_resize_box_3.png 2x" src=/basic/redis/review/01/img/image-20230921134241331_hu031c61dc5645769e387a67ea59594a16_92180_660x0_resize_box_3.png alt></figure></p><div id=43-混合持久化 class=anchor></div><h3 class="relative group">4.3 混合持久化
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#43-%e6%b7%b7%e5%90%88%e6%8c%81%e4%b9%85%e5%8c%96 aria-label=Anchor>#</a></span></h3><p>RDB 优点是数据恢复速度快，但是快照的频率不好把握。频率太低，丢失的数据就会比较多，频率太高，就会影响性能。</p><p>AOF 优点是丢失数据少，但是数据恢复不快。</p><p>为了集成了两者的优点， Redis 4.0 提出了<strong>混合使用 AOF 日志和内存快照</strong>，也叫混合持久化，既保证了 Redis 重启速度，又降低数据丢失风险。</p><p>混合持久化工作在 <strong>AOF 日志重写过程</strong>，当开启了混合持久化时，在 AOF 重写日志时，fork 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。</p><p>也就是说，使用了混合持久化，AOF 文件的<strong>前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据</strong>。</p><p><figure><img class="my-0 rounded-md" srcset="/basic/redis/review/01/img/image-20230921134301768_hu00d591287c4da1528a988b83fd5b84d5_38269_330x0_resize_box_3.png 330w,
/basic/redis/review/01/img/image-20230921134301768_hu00d591287c4da1528a988b83fd5b84d5_38269_660x0_resize_box_3.png 660w,
/basic/redis/review/01/img/image-20230921134301768_hu00d591287c4da1528a988b83fd5b84d5_38269_1024x0_resize_box_3.png 1024w,
/basic/redis/review/01/img/image-20230921134301768_hu00d591287c4da1528a988b83fd5b84d5_38269_1320x0_resize_box_3.png 2x" src=/basic/redis/review/01/img/image-20230921134301768_hu00d591287c4da1528a988b83fd5b84d5_38269_660x0_resize_box_3.png alt></figure></p><p>这样的好处在于，重启 Redis 加载数据的时候，由于前半部分是 RDB 内容，这样<strong>加载的时候速度会很快</strong>。</p><p>加载完 RDB 的内容后，才会加载后半部分的 AOF 内容，这里的内容是 Redis 后台子进程重写 AOF 期间，主线程处理的操作命令，可以使得<strong>数据更少的丢失</strong>。</p><p><strong>混合持久化优点：</strong></p><ul><li>混合持久化结合了 RDB 和 AOF 持久化的优点，开头为 RDB 的格式，使得 Redis 可以更快的启动，同时结合 AOF 的优点，有减低了大量数据丢失的风险。</li></ul><p><strong>混合持久化缺点：</strong></p><ul><li>AOF 文件中添加了 RDB 格式的内容，使得 AOF 文件的可读性变得很差；</li><li>兼容性差，如果开启混合持久化，那么此混合持久化 AOF 文件，就不能用在 Redis 4.0 之前版本了。</li></ul><div id=5redis-过期删除与内存淘汰 class=anchor></div><h2 class="relative group">5.Redis 过期删除与内存淘汰
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#5redis-%e8%bf%87%e6%9c%9f%e5%88%a0%e9%99%a4%e4%b8%8e%e5%86%85%e5%ad%98%e6%b7%98%e6%b1%b0 aria-label=Anchor>#</a></span></h2><div id=51-redis-的过期删除策略 class=anchor></div><h3 class="relative group">5.1 Redis 的过期删除策略
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#51-redis-%e7%9a%84%e8%bf%87%e6%9c%9f%e5%88%a0%e9%99%a4%e7%ad%96%e7%95%a5 aria-label=Anchor>#</a></span></h3><p>Redis 是可以对 key 设置过期时间的，因此需要有相应的机制将已过期的键值对删除，而做这个工作的就是过期键值删除策略。</p><p>每当我们对一个 key 设置了过期时间时，Redis 会把该 key 带上过期时间存储到一个<strong>过期字典</strong>（expires dict）中，也就是说「过期字典」保存了数据库中所有 key 的过期时间。</p><p>当我们查询一个 key 时，Redis 首先检查该 key 是否存在于过期字典中：</p><ul><li>如果不在，则正常读取键值；</li><li>如果存在，则会获取该 key 的过期时间，然后与当前系统时间进行比对，如果比系统时间大，那就没有过期，否则判定该 key 已过期。</li></ul><p>Redis 使用的过期删除策略是「<strong>惰性删除+定期删除</strong>」这两种策略配和使用。</p><blockquote><p>什么是惰性删除策略？</p></blockquote><p>惰性删除策略的做法是，<strong>不主动删除过期键，每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该 key。</strong></p><p>惰性删除的流程图如下：</p><p><figure><img class="my-0 rounded-md" srcset="/basic/redis/review/01/img/image-20230921145248233_hu10484f3b5079fea3eabae14d31e00b60_211205_330x0_resize_box_3.png 330w,
/basic/redis/review/01/img/image-20230921145248233_hu10484f3b5079fea3eabae14d31e00b60_211205_660x0_resize_box_3.png 660w,
/basic/redis/review/01/img/image-20230921145248233_hu10484f3b5079fea3eabae14d31e00b60_211205_1024x0_resize_box_3.png 1024w,
/basic/redis/review/01/img/image-20230921145248233_hu10484f3b5079fea3eabae14d31e00b60_211205_1320x0_resize_box_3.png 2x" src=/basic/redis/review/01/img/image-20230921145248233_hu10484f3b5079fea3eabae14d31e00b60_211205_660x0_resize_box_3.png alt></figure></p><p>惰性删除策略的<strong>优点</strong>：</p><ul><li>因为每次访问时，才会检查 key 是否过期，所以此策略只会使用很少的系统资源，因此，惰性删除策略对 CPU 时间最友好。</li></ul><p>惰性删除策略的<strong>缺点</strong>：</p><ul><li>如果一个 key 已经过期，而这个 key 又仍然保留在数据库中，那么只要这个过期 key 一直没有被访问，它所占用的内存就不会释放，造成了一定的内存空间浪费。所以，惰性删除策略对内存不友好。</li></ul><blockquote><p>什么是定期删除策略？</p></blockquote><p>定期删除策略的做法是，<strong>每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。</strong></p><p>Redis 的定期删除的流程：</p><ol><li>从过期字典中随机抽取 20 个 key；</li><li>检查这 20 个 key 是否过期，并删除已过期的 key；</li><li>如果本轮检查的已过期 key 的数量，超过 5 个（20/4），也就是「已过期 key 的数量」占比「随机抽取 key 的数量」大于 25%，则继续重复步骤 1；如果已过期的 key 比例小于 25%，则停止继续删除过期 key，然后等待下一轮再检查。</li></ol><p>可以看到，定期删除是一个循环的流程。那 Redis 为了保证定期删除不会出现循环过度，导致线程卡死现象，为此增加了定期删除循环流程的时间上限，默认不会超过 25ms。</p><p>定期删除的流程如下：</p><p><figure><img class="my-0 rounded-md" srcset="/basic/redis/review/01/img/image-20230921145300273_hu1f432bd056f242d6c704013d69509bea_333924_330x0_resize_box_3.png 330w,
/basic/redis/review/01/img/image-20230921145300273_hu1f432bd056f242d6c704013d69509bea_333924_660x0_resize_box_3.png 660w,
/basic/redis/review/01/img/image-20230921145300273_hu1f432bd056f242d6c704013d69509bea_333924_1024x0_resize_box_3.png 1024w,
/basic/redis/review/01/img/image-20230921145300273_hu1f432bd056f242d6c704013d69509bea_333924_1320x0_resize_box_3.png 2x" src=/basic/redis/review/01/img/image-20230921145300273_hu1f432bd056f242d6c704013d69509bea_333924_660x0_resize_box_3.png alt></figure></p><p>定期删除策略的<strong>优点</strong>：</p><ul><li>通过限制删除操作执行的时长和频率，来减少删除操作对 CPU 的影响，同时也能删除一部分过期的数据减少了过期键对空间的无效占用。</li></ul><p>定期删除策略的<strong>缺点</strong>：</p><ul><li>难以确定删除操作执行的时长和频率。如果执行的太频繁，就会对 CPU 不友好；如果执行的太少，那又和惰性删除一样了，过期 key 占用的内存不会及时得到释放。</li></ul><p>可以看到，惰性删除策略和定期删除策略都有各自的优点，所以 <strong>Redis 选择「惰性删除+定期删除」这两种策略配和使用</strong>，以求在合理使用 CPU 时间和避免内存浪费之间取得平衡。</p><div id=52-redis-持久化时如何处理过期键 class=anchor></div><h3 class="relative group">5.2 Redis 持久化时，如何处理过期键
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#52-redis-%e6%8c%81%e4%b9%85%e5%8c%96%e6%97%b6%e5%a6%82%e4%bd%95%e5%a4%84%e7%90%86%e8%bf%87%e6%9c%9f%e9%94%ae aria-label=Anchor>#</a></span></h3><p>Redis 持久化文件有两种格式：RDB（Redis Database）和 AOF（Append Only File），分别来看过期键在这两种格式中的呈现状态。</p><p>RDB 文件分为两个阶段，RDB 文件生成阶段和加载阶段。</p><ul><li><strong>RDB 文件生成阶段</strong>：从内存状态持久化成 RDB（文件）的时候，会对 key 进行过期检查，<strong>过期的键「不会」被保存到新的 RDB 文件中</strong>，因此 Redis 中的过期键不会对生成新 RDB 文件产生任何影响。</li><li><strong>RDB 加载阶段</strong>：RDB 加载阶段时，要看服务器是主服务器还是从服务器，分别对应以下两种情况：<ul><li><strong>如果 Redis 是「主服务器」运行模式的话，在载入 RDB 文件时，程序会对文件中保存的键进行检查，过期键「不会」被载入到数据库中</strong>。所以过期键不会对载入 RDB 文件的主服务器造成影响；</li><li><strong>如果 Redis 是「从服务器」运行模式的话，在载入 RDB 文件时，不论键是否过期都会被载入到数据库中</strong>。但由于主从服务器在进行数据同步时，从服务器的数据会被清空。所以一般来说，过期键对载入 RDB 文件的从服务器也不会造成影响。</li></ul></li></ul><p>AOF 文件分为两个阶段，AOF 文件写入阶段和 AOF 重写阶段。</p><ul><li><strong>AOF 文件写入阶段</strong>：当 Redis 以 AOF 模式持久化时，<strong>如果数据库某个过期键还没被删除，那么 AOF 文件会保留此过期键，当此过期键被删除后，Redis 会向 AOF 文件追加一条 DEL 命令来显式地删除该键值</strong>。</li><li><strong>AOF 重写阶段</strong>：执行 AOF 重写时，会对 Redis 中的键值对进行检查，<strong>已过期的键不会被保存到重写后的 AOF 文件中</strong>，因此不会对 AOF 重写造成任何影响。</li></ul><div id=53-redis-主从模式中如何处理过期键 class=anchor></div><h3 class="relative group">5.3 Redis 主从模式中，如何处理过期键
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#53-redis-%e4%b8%bb%e4%bb%8e%e6%a8%a1%e5%bc%8f%e4%b8%ad%e5%a6%82%e4%bd%95%e5%a4%84%e7%90%86%e8%bf%87%e6%9c%9f%e9%94%ae aria-label=Anchor>#</a></span></h3><p>当 Redis 运行在主从模式下时，<strong>从库不会进行过期扫描，从库对过期的处理是被动的</strong>。也就是即使从库中的 key 过期了，如果有客户端访问从库时，依然可以得到 key 对应的值，像未过期的键值对一样返回。</p><p>从库的过期键处理依靠主服务器控制，<strong>主库在 key 到期时，会在 AOF 文件里增加一条 del 指令，同步到所有的从库</strong>，从库通过执行这条 del 指令来删除过期的 key。</p><div id=54-redis-内存满了会发生什么 class=anchor></div><h3 class="relative group">5.4 Redis 内存满了，会发生什么
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#54-redis-%e5%86%85%e5%ad%98%e6%bb%a1%e4%ba%86%e4%bc%9a%e5%8f%91%e7%94%9f%e4%bb%80%e4%b9%88 aria-label=Anchor>#</a></span></h3><p>在 Redis 的运行内存达到了某个阀值，就会触发<strong>内存淘汰机制</strong>，这个阀值就是我们设置的最大运行内存，此值在 Redis 的配置文件中可以找到，配置项为 maxmemory。</p><div id=55-redis-内存淘汰策略 class=anchor></div><h3 class="relative group">5.5 Redis 内存淘汰策略
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#55-redis-%e5%86%85%e5%ad%98%e6%b7%98%e6%b1%b0%e7%ad%96%e7%95%a5 aria-label=Anchor>#</a></span></h3><p>Redis 内存淘汰策略共有八种，这八种策略大体分为「不进行数据淘汰」和「进行数据淘汰」两类策略。</p><p><strong>1、不进行数据淘汰的策略</strong></p><p><strong>noeviction</strong>（Redis3.0之后，默认的内存淘汰策略） ：它表示当运行内存超过最大设置内存时，不淘汰任何数据，而是不再提供服务，直接返回错误。</p><p><strong>2、进行数据淘汰的策略</strong></p><p>针对「进行数据淘汰」这一类策略，又可以细分为「在设置了过期时间的数据中进行淘汰」和「在所有数据范围内进行淘汰」这两类策略。 在设置了过期时间的数据中进行淘汰：</p><ul><li><strong>volatile-random</strong>：随机淘汰设置了过期时间的任意键值；</li><li><strong>volatile-ttl</strong>：优先淘汰更早过期的键值。</li><li><strong>volatile-lru</strong>（Redis3.0 之前，默认的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最久未使用的键值；</li><li><strong>volatile-lfu</strong>（Redis 4.0 后新增的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最少使用的键值；</li></ul><p>在所有数据范围内进行淘汰：</p><ul><li><strong>allkeys-random</strong>：随机淘汰任意键值;</li><li><strong>allkeys-lru</strong>：淘汰整个键值中最久未使用的键值；</li><li><strong>allkeys-lfu</strong>（Redis 4.0 后新增的内存淘汰策略）：淘汰整个键值中最少使用的键值。</li></ul><div id=56-lru-算法和-lfu-算法区别 class=anchor></div><h3 class="relative group">5.6 LRU 算法和 LFU 算法区别
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#56-lru-%e7%ae%97%e6%b3%95%e5%92%8c-lfu-%e7%ae%97%e6%b3%95%e5%8c%ba%e5%88%ab aria-label=Anchor>#</a></span></h3><blockquote><p>什么是 LRU 算法？</p></blockquote><p><strong>LRU</strong> 全称是 Least Recently Used 翻译为<strong>最近最少使用</strong>，会选择淘汰最近最少使用的数据。</p><p>传统 LRU 算法的实现是基于「链表」结构，链表中的元素按照操作顺序从前往后排列，最新操作的键会被移动到表头，当需要内存淘汰时，只需要删除链表尾部的元素即可，因为链表尾部的元素就代表最久未被使用的元素。</p><p>Redis 并没有使用这样的方式实现 LRU 算法，因为传统的 LRU 算法存在两个问题：</p><ul><li>需要用链表管理所有的缓存数据，这会带来额外的空间开销；</li><li>当有数据被访问时，需要在链表上把该数据移动到头端，如果有大量数据被访问，就会带来很多链表移动操作，会很耗时，进而会降低 Redis 缓存性能。</li></ul><blockquote><p>Redis 是如何实现 LRU 算法的？</p></blockquote><p>Redis 实现的是一种<strong>近似 LRU 算法</strong>，目的是为了更好的节约内存，它的<strong>实现方式是在 Redis 的对象结构体中添加一个额外的字段，用于记录此数据的最后一次访问时间</strong>。</p><p>当 Redis 进行内存淘汰时，会使用<strong>随机采样的方式来淘汰数据</strong>，它是随机取 5 个值（此值可配置），然后<strong>淘汰最久没有使用的那个</strong>。</p><p>Redis 实现的 LRU 算法的优点：</p><ul><li>不用为所有的数据维护一个大链表，节省了空间占用；</li><li>不用在每次数据访问时都移动链表项，提升了缓存的性能；</li></ul><p>但是 LRU 算法有一个问题，<strong>无法解决缓存污染问题</strong>，比如应用一次读取了大量的数据，而这些数据只会被读取这一次，那么这些数据会留存在 Redis 缓存中很长一段时间，造成缓存污染。</p><p>因此，在 Redis 4.0 之后引入了 LFU 算法来解决这个问题。</p><blockquote><p>什么是 LFU 算法？</p></blockquote><p>LFU 全称是 Least Frequently Used 翻译为<strong>最近最不常用的</strong>，LFU 算法是根据数据访问次数来淘汰数据的，它的核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”。</p><p>所以， LFU 算法会记录每个数据的访问次数。当一个数据被再次访问时，就会增加该数据的访问次数。这样就解决了偶尔被访问一次之后，数据留存在缓存中很长一段时间的问题，相比于 LRU 算法也更合理一些。</p><blockquote><p>Redis 是如何实现 LFU 算法的？</p></blockquote><p>LFU 算法相比于 LRU 算法的实现，多记录了「数据的访问频次」的信息。Redis 对象的结构如下：</p><pre tabindex=0><code>typedef struct redisObject {
    ...
      
    // 24 bits，用于记录对象的访问信息
    unsigned lru:24;  
    ...
} robj;
</code></pre><p>Redis 对象头中的 lru 字段，在 LRU 算法下和 LFU 算法下使用方式并不相同。</p><p><strong>在 LRU 算法中</strong>，Redis 对象头的 24 bits 的 lru 字段是用来记录 key 的访问时间戳，因此在 LRU 模式下，Redis可以根据对象头中的 lru 字段记录的值，来比较最后一次 key 的访问时间长，从而淘汰最久未被使用的 key。</p><p><strong>在 LFU 算法中</strong>，Redis对象头的 24 bits 的 lru 字段被分成两段来存储，高 16bit 存储 ldt(Last Decrement Time)，用来记录 key 的访问时间戳；低 8bit 存储 logc(Logistic Counter)，用来记录 key 的访问频次。</p><p><figure><img class="my-0 rounded-md" srcset="/basic/redis/review/01/img/image-20230921150011528_hufb90ab361a70e11f94f323f869053c5b_85756_330x0_resize_box_3.png 330w,
/basic/redis/review/01/img/image-20230921150011528_hufb90ab361a70e11f94f323f869053c5b_85756_660x0_resize_box_3.png 660w,
/basic/redis/review/01/img/image-20230921150011528_hufb90ab361a70e11f94f323f869053c5b_85756_1024x0_resize_box_3.png 1024w,
/basic/redis/review/01/img/image-20230921150011528_hufb90ab361a70e11f94f323f869053c5b_85756_1320x0_resize_box_3.png 2x" src=/basic/redis/review/01/img/image-20230921150011528_hufb90ab361a70e11f94f323f869053c5b_85756_660x0_resize_box_3.png alt></figure></p><div id=6缓存更新策略 class=anchor></div><h2 class="relative group">6.缓存更新策略
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#6%e7%bc%93%e5%ad%98%e6%9b%b4%e6%96%b0%e7%ad%96%e7%95%a5 aria-label=Anchor>#</a></span></h2><p>常见的缓存更新策略共有3种：</p><ul><li>Cache Aside（旁路缓存）策略；</li><li>Read/Write Through（读穿 / 写穿）策略；</li><li>Write Back（写回）策略；</li></ul><p>实际开发中，Redis 和 MySQL 的更新策略用的是 Cache Aside，另外两种策略应用不了。</p><div id=61-cache-aside旁路缓存策略 class=anchor></div><h3 class="relative group">6.1 Cache Aside（旁路缓存）策略
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#61-cache-aside%e6%97%81%e8%b7%af%e7%bc%93%e5%ad%98%e7%ad%96%e7%95%a5 aria-label=Anchor>#</a></span></h3><p>Cache Aside（旁路缓存）策略是最常用的，应用程序直接与「数据库、缓存」交互，并负责对缓存的维护，该策略又可以细分为「读策略」和「写策略」。</p><p><figure><img class="my-0 rounded-md" srcset="/basic/redis/review/01/img/image-20230921151705099_hua59885121d5acdd279ffc68adb37cde1_143614_330x0_resize_box_3.png 330w,
/basic/redis/review/01/img/image-20230921151705099_hua59885121d5acdd279ffc68adb37cde1_143614_660x0_resize_box_3.png 660w,
/basic/redis/review/01/img/image-20230921151705099_hua59885121d5acdd279ffc68adb37cde1_143614_1024x0_resize_box_3.png 1024w,
/basic/redis/review/01/img/image-20230921151705099_hua59885121d5acdd279ffc68adb37cde1_143614_1320x0_resize_box_3.png 2x" src=/basic/redis/review/01/img/image-20230921151705099_hua59885121d5acdd279ffc68adb37cde1_143614_660x0_resize_box_3.png alt></figure></p><p><strong>写策略的步骤：</strong></p><ul><li>先更新数据库中的数据，再删除缓存中的数据。</li></ul><p><strong>读策略的步骤：</strong></p><ul><li>如果读取的数据命中了缓存，则直接返回数据；</li><li>如果读取的数据没有命中缓存，则从数据库中读取数据，然后将数据写入到缓存，并且返回给用户。</li></ul><p>注意，写策略的步骤的顺序不能倒过来，即<strong>不能先删除缓存再更新数据库</strong>，原因是在「读+写」并发的时候，会出现缓存和数据库的数据不一致性的问题。</p><p>举个例子，假设某个用户的年龄是 20，请求 A 要更新用户年龄为 21，所以它会删除缓存中的内容。这时，另一个请求 B 要读取这个用户的年龄，它查询缓存发现未命中后，会从数据库中读取到年龄为 20，并且写入到缓存中，然后请求 A 继续更改数据库，将用户的年龄更新为 21。</p><p><figure><img class="my-0 rounded-md" srcset="/basic/redis/review/01/img/image-20230921151720414_hub38fa8992ec52e8897f9924707450fb6_150241_330x0_resize_box_3.png 330w,
/basic/redis/review/01/img/image-20230921151720414_hub38fa8992ec52e8897f9924707450fb6_150241_660x0_resize_box_3.png 660w,
/basic/redis/review/01/img/image-20230921151720414_hub38fa8992ec52e8897f9924707450fb6_150241_1024x0_resize_box_3.png 1024w,
/basic/redis/review/01/img/image-20230921151720414_hub38fa8992ec52e8897f9924707450fb6_150241_1320x0_resize_box_3.png 2x" src=/basic/redis/review/01/img/image-20230921151720414_hub38fa8992ec52e8897f9924707450fb6_150241_660x0_resize_box_3.png alt></figure></p><p>最终，该用户年龄在缓存中是 20（旧值），在数据库中是 21（新值），缓存和数据库的数据不一致。</p><p><strong>为什么「先更新数据库再删除缓存」不会有数据不一致的问题？</strong></p><p>继续用「读 + 写」请求的并发的场景来分析。</p><p>假如某个用户数据在缓存中不存在，请求 A 读取数据时从数据库中查询到年龄为 20，在未写入缓存中时另一个请求 B 更新数据。它更新数据库中的年龄为 21，并且清空缓存。这时请求 A 把从数据库中读到的年龄为 20 的数据写入到缓存中。</p><p><figure><img class="my-0 rounded-md" srcset="/basic/redis/review/01/img/image-20230921151732019_hu4aee77a5123ab2161847c7e55dc75796_151362_330x0_resize_box_3.png 330w,
/basic/redis/review/01/img/image-20230921151732019_hu4aee77a5123ab2161847c7e55dc75796_151362_660x0_resize_box_3.png 660w,
/basic/redis/review/01/img/image-20230921151732019_hu4aee77a5123ab2161847c7e55dc75796_151362_1024x0_resize_box_3.png 1024w,
/basic/redis/review/01/img/image-20230921151732019_hu4aee77a5123ab2161847c7e55dc75796_151362_1320x0_resize_box_3.png 2x" src=/basic/redis/review/01/img/image-20230921151732019_hu4aee77a5123ab2161847c7e55dc75796_151362_660x0_resize_box_3.png alt></figure></p><p>最终，该用户年龄在缓存中是 20（旧值），在数据库中是 21（新值），缓存和数据库数据不一致。 从上面的理论上分析，先更新数据库，再删除缓存也是会出现数据不一致性的问题，<strong>但是在实际中，这个问题出现的概率并不高</strong>。</p><p><strong>因为缓存的写入通常要远远快于数据库的写入</strong>，所以在实际中很难出现请求 B 已经更新了数据库并且删除了缓存，请求 A 才更新完缓存的情况。而一旦请求 A 早于请求 B 删除缓存之前更新了缓存，那么接下来的请求就会因为缓存不命中而从数据库中重新读取数据，所以不会出现这种不一致的情况。</p><p><strong>Cache Aside 策略适合读多写少的场景，不适合写多的场景</strong>，因为当写入比较频繁时，缓存中的数据会被频繁地清理，这样会对缓存的命中率有一些影响。如果业务对缓存命中率有严格的要求，那么可以考虑两种解决方案：</p><ul><li>一种做法是在更新数据时也更新缓存，只是在更新缓存前先加一个分布式锁，因为这样在同一时间只允许一个线程更新缓存，就不会产生并发问题了。当然这么做对于写入的性能会有一些影响；</li><li>另一种做法同样也是在更新数据时更新缓存，只是给缓存加一个较短的过期时间，这样即使出现缓存不一致的情况，缓存的数据也会很快过期，对业务的影响也是可以接受。</li></ul><div id=62-readwrite-through读穿--写穿策略 class=anchor></div><h3 class="relative group">6.2 Read/Write Through（读穿 / 写穿）策略
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#62-readwrite-through%e8%af%bb%e7%a9%bf--%e5%86%99%e7%a9%bf%e7%ad%96%e7%95%a5 aria-label=Anchor>#</a></span></h3><p>Read/Write Through（读穿 / 写穿）策略原则是应用程序只和缓存交互，不再和数据库交互，而是由缓存和数据库交互，相当于更新数据库的操作由缓存自己代理了。</p><p><strong>1、Read Through 策略</strong></p><p>先查询缓存中数据是否存在，如果存在则直接返回，如果不存在，则由缓存组件负责从数据库查询数据，并将结果写入到缓存组件，最后缓存组件将数据返回给应用。</p><p><strong>2、Write Through 策略</strong></p><p>当有数据更新的时候，先查询要写入的数据在缓存中是否已经存在：</p><ul><li>如果缓存中数据已经存在，则更新缓存中的数据，并且由缓存组件同步更新到数据库中，然后缓存组件告知应用程序更新完成。</li><li>如果缓存中数据不存在，直接更新数据库，然后返回；</li></ul><p>下面是 Read Through/Write Through 策略的示意图：</p><p><figure><img class="my-0 rounded-md" srcset="/basic/redis/review/01/img/image-20230921151753173_hue2a1f22b969996e3c5414f832914192b_301201_330x0_resize_box_3.png 330w,
/basic/redis/review/01/img/image-20230921151753173_hue2a1f22b969996e3c5414f832914192b_301201_660x0_resize_box_3.png 660w,
/basic/redis/review/01/img/image-20230921151753173_hue2a1f22b969996e3c5414f832914192b_301201_1024x0_resize_box_3.png 1024w,
/basic/redis/review/01/img/image-20230921151753173_hue2a1f22b969996e3c5414f832914192b_301201_1320x0_resize_box_3.png 2x" src=/basic/redis/review/01/img/image-20230921151753173_hue2a1f22b969996e3c5414f832914192b_301201_660x0_resize_box_3.png alt></figure></p><p>Read Through/Write Through 策略的特点是由缓存节点而非应用程序来和数据库打交道，在我们开发过程中相比 Cache Aside 策略要少见一些，原因是我们经常使用的分布式缓存组件，无论是 Memcached 还是 Redis 都不提供写入数据库和自动加载数据库中的数据的功能。而我们在使用本地缓存的时候可以考虑使用这种策略。</p><div id=63-write-back写回策略 class=anchor></div><h3 class="relative group">6.3 Write Back（写回）策略
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#63-write-back%e5%86%99%e5%9b%9e%e7%ad%96%e7%95%a5 aria-label=Anchor>#</a></span></h3><p>Write Back（写回）策略在更新数据的时候，只更新缓存，同时将缓存数据设置为脏的，然后立马返回，并不会更新数据库。对于数据库的更新，会通过批量异步更新的方式进行。</p><p>实际上，Write Back（写回）策略也不能应用到我们常用的数据库和缓存的场景中，因为 Redis 并没有异步更新数据库的功能。</p><p>Write Back 是计算机体系结构中的设计，比如 CPU 的缓存、操作系统中文件系统的缓存都采用了 Write Back（写回）策略。</p><p><strong>Write Back 策略特别适合写多的场景</strong>，因为发生写操作的时候， 只需要更新缓存，就立马返回了。比如，写文件的时候，实际上是写入到文件系统的缓存就返回了，并不会写磁盘。</p><p><strong>但是带来的问题是，数据不是强一致性的，而且会有数据丢失的风险</strong>，因为缓存一般使用内存，而内存是非持久化的，所以一旦缓存机器掉电，就会造成原本缓存中的脏数据丢失。所以你会发现系统在掉电之后，之前写入的文件会有部分丢失，就是因为 Page Cache 还没有来得及刷盘造成的。</p><p>这里贴一张 CPU 缓存与内存使用 Write Back 策略的流程图：</p><p><figure><img class="my-0 rounded-md" srcset="/basic/redis/review/01/img/image-20230921151806491_hud68a9e7bb874fa8c1384187efa968e96_212202_330x0_resize_box_3.png 330w,
/basic/redis/review/01/img/image-20230921151806491_hud68a9e7bb874fa8c1384187efa968e96_212202_660x0_resize_box_3.png 660w,
/basic/redis/review/01/img/image-20230921151806491_hud68a9e7bb874fa8c1384187efa968e96_212202_1024x0_resize_box_3.png 1024w,
/basic/redis/review/01/img/image-20230921151806491_hud68a9e7bb874fa8c1384187efa968e96_212202_1320x0_resize_box_3.png 2x" src=/basic/redis/review/01/img/image-20230921151806491_hud68a9e7bb874fa8c1384187efa968e96_212202_660x0_resize_box_3.png alt></figure></p></div></div><script>var oid="views_basic/redis/review/01/index.md",oid_likes="likes_basic/redis/review/01/index.md"</script><script type=text/javascript src=/js/page.min.0e49973b4ad0a382c7c6012d8bff8226316642daabc4f8a20477bd08674f3da6e2fa993bc20ad4f51e7c5bb68e6f913a207a7c4fe37ea0e7b806894afce0a64e.js integrity="sha512-DkmXO0rQo4LHxgEti/+CJjFmQtqrxPiiBHe9CGdPPabi+pk7wgrU9R58W7aOb5E6IHp8T+N+oOe4BolK/OCmTg=="></script></section><footer class="pt-8 max-w-prose print:hidden"><div class=pt-8><hr class="border-dotted border-neutral-300 dark:border-neutral-600"><div class="flex justify-between pt-3"><span><a class="flex group mr-3" href=/basic/mysql/review/01/><span class="mr-3 text-neutral-700 group-hover:text-primary-600 ltr:inline rtl:hidden dark:text-neutral dark:group-hover:text-primary-400">&larr;</span>
<span class="ml-3 text-neutral-700 group-hover:text-primary-600 ltr:hidden rtl:inline dark:text-neutral dark:group-hover:text-primary-400">&rarr;</span>
<span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">MySQL 基础</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"><time datetime="2023-09-22 09:59:56 +0800 +0800">22 September 2023</time></span></span></a></span>
<span><a class="flex text-right group ml-3" href=/basic/redis/review/02/><span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">Redis 大 Key</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"><time datetime="2023-09-21 15:24:14 +0800 +0800">21 September 2023</time></span></span>
<span class="ml-3 text-neutral-700 group-hover:text-primary-600 ltr:inline rtl:hidden dark:text-neutral dark:group-hover:text-primary-400">&rarr;</span>
<span class="mr-3 text-neutral-700 group-hover:text-primary-600 ltr:hidden rtl:inline dark:text-neutral dark:group-hover:text-primary-400">&larr;</span></a></span></div></div></footer></article><div id=top-scroller class="pointer-events-none absolute top-[110vh] bottom-0 w-12 ltr:right-0 rtl:left-0"><a href=#the-top class="pointer-events-auto sticky top-[calc(100vh-5.5rem)] flex h-12 w-12 mb-16 items-center justify-center rounded-full bg-neutral/50 text-xl text-neutral-700 backdrop-blur hover:text-primary-600 dark:bg-neutral-800/50 dark:text-neutral dark:hover:text-primary-400" aria-label="Scroll to top" title="Scroll to top">&uarr;</a></div></main><footer id=site-footer class="py-10 print:hidden"><div class="flex items-center justify-between"><p class="text-sm text-neutral-500 dark:text-neutral-400">&copy;
2023</p></div><script>mediumZoom(document.querySelectorAll("img:not(.nozoom)"),{margin:24,background:"rgba(0,0,0,0.5)",scrollOffset:0})</script><script type=text/javascript src=/js/process.min.35c1113bcc16c5a59bf031082f9e63822aa95280423881a7847a7ff33a16e6299ce6a840d9ef4e10d947e030a18f3f20359afb2ec0f35967484b9a9360ac3145.js integrity="sha512-NcERO8wWxaWb8DEIL55jgiqpUoBCOIGnhHp/8zoW5imc5qhA2e9OENlH4DChjz8gNZr7LsDzWWdIS5qTYKwxRQ=="></script></footer><div id=search-wrapper class="invisible fixed inset-0 flex h-screen w-screen cursor-default flex-col bg-neutral-500/50 p-4 backdrop-blur-sm dark:bg-neutral-900/50 sm:p-6 md:p-[10vh] lg:p-[12vh]" data-url=https://newtsun.github.io style=z-index:500><div id=search-modal class="flex flex-col w-full max-w-3xl min-h-0 mx-auto border rounded-md shadow-lg top-20 border-neutral-200 bg-neutral dark:border-neutral-700 dark:bg-neutral-800"><header class="relative z-10 flex items-center justify-between flex-none px-2"><form class="flex items-center flex-auto min-w-0"><div class="flex items-center justify-center w-8 h-8 text-neutral-400"><span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></div><input type=search id=search-query class="flex flex-auto h-12 mx-1 bg-transparent appearance-none focus:outline-dotted focus:outline-2 focus:outline-transparent" placeholder=Search tabindex=0></form><button id=close-search-button class="flex items-center justify-center w-8 h-8 text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400" title="Close (Esc)">
<span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path fill="currentcolor" d="M310.6 361.4c12.5 12.5 12.5 32.75.0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3 54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75.0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75.0-45.25s32.75-12.5 45.25.0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25.0s12.5 32.75.0 45.25l-105.4 105.4L310.6 361.4z"/></svg></span></button></header><section class="flex-auto px-2 overflow-auto"><ul id=search-results></ul></section></div></div></div></body></html>